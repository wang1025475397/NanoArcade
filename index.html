<!DOCTYPE HTML>
<!--
	NanoArcade
	Based on Hyperspace by HTML5 UP (html5up.net | @ajlkn)
-->
<html>
	<head>
		<title>NanoArcade</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<meta name="description" content="Box art manager for retro gaming handhelds - RG Nano, Miyoo Mini, Trimui Brick and more">
		<meta name="theme-color" content="#6c5ce7">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta name="apple-mobile-web-app-title" content="NanoArcade">
		<link rel="icon" type="image/png" sizes="32x32" href="assets/images/favicon.png">
		<link rel="apple-touch-icon" href="assets/images/icon-192.png">
		<link rel="manifest" href="manifest.json">
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Cookie&family=Press+Start+2P&display=swap" rel="stylesheet">
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<style>
			/* Theme CSS Variables */
			:root {
				--theme-primary: #3b82f6;
				--theme-primary-dark: #1d4ed8;
				--theme-primary-glow: rgba(59, 130, 246, 0.4);
				--theme-primary-light: #60a5fa;
				--theme-accent: #3b82f6;
				--theme-bg-gradient-start: #1a1a2e;
				--theme-bg-gradient-end: #16213e;
				--theme-text-glow: 0 0 8px rgba(96, 165, 250, 0.6), 0 0 15px rgba(59, 130, 246, 0.4);
				--theme-sidebar-bg: #1e3a5f;
				--theme-footer-bg: #1e40af;
				--theme-nav-underline: #1e4976;
			}

			/* Blue Theme (Default) */
			[data-theme="blue"] {
				--theme-primary: #3b82f6;
				--theme-primary-dark: #1d4ed8;
				--theme-primary-glow: rgba(59, 130, 246, 0.4);
				--theme-primary-light: #60a5fa;
				--theme-accent: #3b82f6;
				--theme-bg-gradient-start: #1a1a2e;
				--theme-bg-gradient-end: #16213e;
				--theme-text-glow: 0 0 8px rgba(96, 165, 250, 0.6), 0 0 15px rgba(59, 130, 246, 0.4);
				--theme-sidebar-bg: #1e3a5f;
				--theme-footer-bg: #1e40af;
				--theme-nav-underline: #1e4976;
			}

			/* Purple Theme */
			[data-theme="purple"] {
				--theme-primary: #8b5cf6;
				--theme-primary-dark: #6d28d9;
				--theme-primary-glow: rgba(139, 92, 246, 0.4);
				--theme-primary-light: #a78bfa;
				--theme-accent: #8b5cf6;
				--theme-bg-gradient-start: #1a1a2e;
				--theme-bg-gradient-end: #2d1b4e;
				--theme-text-glow: 0 0 8px rgba(167, 139, 250, 0.6), 0 0 15px rgba(139, 92, 246, 0.4);
				--theme-sidebar-bg: #2d1b4e;
				--theme-footer-bg: #5b21b6;
				--theme-nav-underline: #4c1d95;
			}

			/* Green Theme */
			[data-theme="green"] {
				--theme-primary: #22c55e;
				--theme-primary-dark: #15803d;
				--theme-primary-glow: rgba(34, 197, 94, 0.4);
				--theme-primary-light: #4ade80;
				--theme-accent: #22c55e;
				--theme-bg-gradient-start: #0f1a14;
				--theme-bg-gradient-end: #14291e;
				--theme-text-glow: 0 0 8px rgba(74, 222, 128, 0.6), 0 0 15px rgba(34, 197, 94, 0.4);
				--theme-sidebar-bg: #14532d;
				--theme-footer-bg: #166534;
				--theme-nav-underline: #15803d;
			}

			/* Red Theme */
			[data-theme="red"] {
				--theme-primary: #ef4444;
				--theme-primary-dark: #b91c1c;
				--theme-primary-glow: rgba(239, 68, 68, 0.4);
				--theme-primary-light: #f87171;
				--theme-accent: #ef4444;
				--theme-bg-gradient-start: #1a1212;
				--theme-bg-gradient-end: #2e1a1a;
				--theme-text-glow: 0 0 8px rgba(248, 113, 113, 0.6), 0 0 15px rgba(239, 68, 68, 0.4);
				--theme-sidebar-bg: #7f1d1d;
				--theme-footer-bg: #991b1b;
				--theme-nav-underline: #b91c1c;
			}

			/* Cyan Theme */
			[data-theme="cyan"] {
				--theme-primary: #06b6d4;
				--theme-primary-dark: #0891b2;
				--theme-primary-glow: rgba(6, 182, 212, 0.4);
				--theme-primary-light: #22d3ee;
				--theme-accent: #06b6d4;
				--theme-bg-gradient-start: #0f1a1c;
				--theme-bg-gradient-end: #0f2937;
				--theme-text-glow: 0 0 8px rgba(34, 211, 238, 0.6), 0 0 15px rgba(6, 182, 212, 0.4);
				--theme-sidebar-bg: #164e63;
				--theme-footer-bg: #155e75;
				--theme-nav-underline: #0e7490;
			}

			/* Orange/Gold Theme */
			[data-theme="orange"] {
				--theme-primary: #f59e0b;
				--theme-primary-dark: #d97706;
				--theme-primary-glow: rgba(245, 158, 11, 0.4);
				--theme-primary-light: #fbbf24;
				--theme-accent: #f59e0b;
				--theme-bg-gradient-start: #1a1610;
				--theme-bg-gradient-end: #2e2415;
				--theme-text-glow: 0 0 8px rgba(251, 191, 36, 0.6), 0 0 15px rgba(245, 158, 11, 0.4);
				--theme-sidebar-bg: #78350f;
				--theme-footer-bg: #92400e;
				--theme-nav-underline: #b45309;
			}

			/* Pink Theme */
			[data-theme="pink"] {
				--theme-primary: #ec4899;
				--theme-primary-dark: #be185d;
				--theme-primary-glow: rgba(236, 72, 153, 0.4);
				--theme-primary-light: #f472b6;
				--theme-accent: #ec4899;
				--theme-bg-gradient-start: #1a1018;
				--theme-bg-gradient-end: #2e1528;
				--theme-text-glow: 0 0 8px rgba(244, 114, 182, 0.6), 0 0 15px rgba(236, 72, 153, 0.4);
				--theme-sidebar-bg: #831843;
				--theme-footer-bg: #9d174d;
				--theme-nav-underline: #be185d;
			}

			/* Apply theme to sidebar and footer */
			#sidebar {
				background: var(--theme-sidebar-bg) !important;
			}

			#footer.wrapper.style1-alt {
				background-color: var(--theme-footer-bg) !important;
			}

			#sidebar nav a:before {
				background: var(--theme-nav-underline) !important;
			}

			#sidebar nav a:after {
				background-image: linear-gradient(to right, var(--theme-primary-dark), var(--theme-primary)) !important;
			}

			/* Apply theme to main content wrapper backgrounds */
			.wrapper.alt {
				background-color: var(--theme-bg-gradient-start) !important;
			}

			.wrapper.style1 {
				background-color: var(--theme-primary) !important;
			}

			.wrapper.style1-alt {
				background-color: var(--theme-primary-dark) !important;
			}

			.wrapper.style2 {
				background-color: var(--theme-primary-dark) !important;
			}

			.wrapper.style2-alt {
				background-color: var(--theme-sidebar-bg) !important;
			}

			.wrapper.style3 {
				background-color: var(--theme-primary) !important;
			}

			.wrapper.style3-alt {
				background-color: var(--theme-primary-dark) !important;
			}

			#wrapper {
				background-color: var(--theme-bg-gradient-start) !important;
			}

			/* Custom styles for NanoArcade */
			#sidebar nav ul li {
				display: flex;
				align-items: center;
				gap: 8px;
			}

			#sidebar nav ul li a {
				color: #fff !important;
				font-family: 'Press Start 2P', cursive;
				font-size: 0.4em;
				line-height: 1.4;
				text-shadow: var(--theme-text-glow);
				border: none !important;
				background: none !important;
				outline: none !important;
				box-shadow: none !important;
				display: flex;
				align-items: center;
				white-space: nowrap;
			}

			#sidebar nav ul li a::before,
			#sidebar nav ul li a::after {
				display: none !important;
			}

			#sidebar nav ul li img.console-icon {
				width: 36px;
				height: 36px;
				object-fit: contain;
				vertical-align: middle;
				margin-right: 12px;
				flex-shrink: 0;
			}

			#sidebar nav ul li .game-count {
				margin-left: 8px;
				background: rgba(255,255,255,0.1);
				padding: 2px 6px;
				border-radius: 10px;
				font-size: 1em;
				flex-shrink: 0;
			}

			#sidebar nav ul li .missing-art-count {
				color: #f59e0b;
				font-size: 0.85em;
				opacity: 0.8;
				flex-shrink: 0;
				display: inline-flex;
				align-items: center;
				gap: 2px;
			}

			#sidebar nav ul li .missing-art-count .icon {
				font-size: 0.9em;
			}

			#sidebar nav ul li a .icon.fa-home {
				margin-right: 10px;
				font-size: 1.5em;
			}

			.games-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
				gap: 1.5em;
				padding: 1em 0;
				align-items: start;
			}

			/* Loading spinner */
			.loading-container {
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				padding: 4em 2em;
				grid-column: 1 / -1;
			}
			.spinner {
				width: 50px;
				height: 50px;
				border: 4px solid rgba(255, 255, 255, 0.1);
				border-top-color: #3b82f6;
				border-radius: 50%;
				animation: spin 1s linear infinite;
			}
			@keyframes spin {
				to { transform: rotate(360deg); }
			}
			.loading-text {
				margin-top: 1em;
				color: rgba(255, 255, 255, 0.6);
				font-size: 1.1em;
			}

			.game-card {
				background: rgba(255,255,255,0.05);
				border-radius: 10px;
				transition: transform 0.3s, box-shadow 0.3s;
				cursor: pointer;
				display: flex;
				flex-direction: column;
			}

			.game-card:hover {
				transform: translateY(-5px);
				box-shadow: 0 10px 30px var(--theme-primary-glow);
			}

			.game-card .image-container {
				width: 100%;
				background: rgba(0,0,0,0.3);
				position: relative;
				border-radius: 10px 10px 0 0;
				overflow: hidden;
			}

			.game-card .image-container img {
				width: 100%;
				height: auto;
				display: block;
			}

			.game-card .no-image {
				color: rgba(255,255,255,0.3);
				font-size: 3em;
				display: flex;
				align-items: center;
				justify-content: center;
				min-height: 180px;
			}

			.game-card .game-name {
				padding: 10px;
				font-size: 0.8em;
				text-align: center;
				white-space: normal;
				word-wrap: break-word;
				overflow-wrap: break-word;
				line-height: 1.3;
				color: #fff;
			}

			.game-card .game-console-label {
				font-size: 0.65em;
				color: rgba(255,255,255,0.5);
				text-align: center;
				padding: 0 10px 8px;
				margin-top: -5px;
			}

			.game-card .missing-badge {
				position: absolute;
				top: 5px;
				right: 5px;
				background: var(--theme-primary);
				color: #fff;
				padding: 3px 8px;
				border-radius: 3px;
				font-size: 0.7em;
			}

			/* Top 25 list styles */
			.top25-item {
				display: flex;
				align-items: center;
				padding: 0.6em 0.75em;
				margin-bottom: 0.4em;
				border-radius: 8px;
				background: rgba(255,255,255,0.03);
				transition: background 0.2s;
			}
			.top25-item:hover {
				background: rgba(255,255,255,0.08);
			}
			.top25-item.owned {
				border-left: 3px solid #22c55e;
			}
			.top25-item.missing {
				border-left: 3px solid #ef4444;
				opacity: 0.8;
			}
			.top25-rank {
				min-width: 36px;
				font-weight: bold;
				color: #f59e0b;
				font-size: 0.85em;
				flex-shrink: 0;
			}
			.top25-icon {
				min-width: 24px;
				text-align: center;
				margin-right: 0.5em;
				flex-shrink: 0;
			}
			.top25-icon.owned { color: #22c55e; }
			.top25-icon.missing { color: #ef4444; }
			.top25-name {
				flex: 1;
				font-size: 0.85em;
			}
			.top25-upload-zone.dragover {
				border-color: #f59e0b;
				background: rgba(245, 158, 11, 0.1);
			}

			/* Top 25 scrollbar */
			#top25List::-webkit-scrollbar {
				width: 8px;
			}
			#top25List::-webkit-scrollbar-track {
				background: rgba(0,0,0,0.2);
				border-radius: 4px;
			}
			#top25List::-webkit-scrollbar-thumb {
				background: rgba(245, 158, 11, 0.5);
				border-radius: 4px;
			}
			#top25List::-webkit-scrollbar-thumb:hover {
				background: rgba(245, 158, 11, 0.7);
			}

			.stats-row {
				display: flex;
				gap: 2em;
				margin-bottom: 2em;
				flex-wrap: wrap;
			}

			.stat-box {
				background: rgba(255,255,255,0.05);
				padding: 1em 2em;
				border-radius: 10px;
				text-align: center;
			}

			.stat-box .value {
				font-size: 2em;
				color: var(--theme-primary-light);
				font-weight: bold;
			}

			.stat-box .label {
				font-size: 0.9em;
				color: rgba(255,255,255,0.55);
			}

			.controls-bar {
				display: flex;
				gap: 1em;
				align-items: center;
				flex-wrap: wrap;
				margin-bottom: 2em;
			}

			/* ========== UIverse 3D Skew Button (btongheng) ========== */
			.btn-3d,
			.btn-3d:focus,
			.btn-3d:hover,
			.btn-3d:active {
				--btn-color: #3b82f6;
				--btn-shadow: #1d4ed8;
				--btn-glow: #3b82f663;
				cursor: pointer;
				display: inline-flex;
				align-items: center;
				justify-content: center;
				gap: 0.5rem;
				padding: 12px 24px;
				font-size: 0.85em;
				font-weight: 700;
				letter-spacing: 1.5px;
				text-transform: uppercase;
				color: #fff;
				background: var(--btn-color);
				border: 2px solid var(--btn-shadow) !important;
				border-radius: 0.75rem;
				box-shadow: 0 6px 0 var(--btn-shadow);
				transform: skew(-10deg);
				transition: all 0.1s ease;
				filter: drop-shadow(0 12px 16px var(--btn-glow));
				outline: none !important;
			}
			.btn-3d:hover {
				transform: skew(-10deg) translateY(-2px);
				box-shadow: 0 8px 0 var(--btn-shadow);
			}
			.btn-3d:active {
				letter-spacing: 0.5px;
				transform: skew(-10deg) translateY(6px);
				box-shadow: 0 0 0 var(--btn-glow);
			}
			.btn-3d .icon {
				transform: skew(10deg);
			}
			.btn-3d::after {
				display: none !important;
			}
			/* Color variants */
			.btn-3d.green {
				--btn-color: #22c55e;
				--btn-shadow: #15803d;
				--btn-glow: #22c55e63;
			}
			.btn-3d.red {
				--btn-color: #ef4444;
				--btn-shadow: #b91c1c;
				--btn-glow: #ef444463;
			}
			.btn-3d.purple {
				--btn-color: #8b5cf6;
				--btn-shadow: #6d28d9;
				--btn-glow: #8b5cf663;
			}
			.btn-3d.cyan {
				--btn-color: #06b6d4;
				--btn-shadow: #0891b2;
				--btn-glow: #06b6d463;
			}
			.btn-3d.gray {
				--btn-color: #64748b;
				--btn-shadow: #475569;
				--btn-glow: #64748b63;
			}
			.btn-3d.small {
				padding: 8px 16px;
				font-size: 0.7em;
				box-shadow: 0 4px 0 var(--btn-shadow);
			}
			.btn-3d.small:hover {
				transform: skew(-10deg) translateY(-2px);
				box-shadow: 0 6px 0 var(--btn-shadow);
			}
			.btn-3d.small:active {
				transform: skew(-10deg) translateY(4px);
			}
			.btn-3d:disabled {
				--btn-color: #475569;
				--btn-shadow: #334155;
				--btn-glow: #47556963;
				cursor: not-allowed;
				opacity: 0.7;
			}
			.btn-3d.active {
				--btn-color: #3b82f6;
				--btn-shadow: #1d4ed8;
				--btn-glow: #3b82f663;
			}
			.btn-3d.gold {
				--btn-color: #f59e0b;
				--btn-shadow: #d97706;
				--btn-glow: #f59e0b63;
			}

			/* URL input styling */
			.url-input {
				flex: 1;
				padding: 0.5em 0.75em;
				font-size: 0.85em;
				background: rgba(0,0,0,0.3);
				border: 1px solid rgba(255,255,255,0.2);
				border-radius: 8px;
				color: white;
				outline: none;
			}
			.url-input:focus {
				border-color: #3b82f6;
			}
			.url-input::placeholder {
				color: rgba(255,255,255,0.4);
			}

			.search-input {
				flex: 1;
				min-width: 200px;
			}

			/* GameFAQs tooltip styles */
			.gf-tooltip {
				display: none;
				position: absolute;
				bottom: 100%;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(0,0,0,0.95);
				border: 1px solid rgba(59, 130, 246, 0.4);
				border-radius: 8px;
				padding: 0.6em 0.8em;
				font-size: 0.85em;
				white-space: nowrap;
				z-index: 100;
				margin-bottom: 0.5em;
				box-shadow: 0 4px 12px rgba(0,0,0,0.5);
			}
			.gf-tooltip::after {
				content: '';
				position: absolute;
				top: 100%;
				left: 50%;
				transform: translateX(-50%);
				border: 6px solid transparent;
				border-top-color: rgba(59, 130, 246, 0.4);
			}
			#gfRatingWrap:hover .gf-tooltip,
			#gfDifficultyWrap:hover .gf-tooltip,
			#gfLengthWrap:hover .gf-tooltip,
			#gameTitleWrap:hover .gf-tooltip {
				display: block;
			}
			#gameTitleTooltip::after {
				top: -12px;
				border-top-color: transparent;
				border-bottom-color: rgba(59, 130, 246, 0.4);
			}
			.gf-tooltip-row {
				display: flex;
				justify-content: space-between;
				gap: 1em;
				padding: 0.15em 0;
				color: rgba(255,255,255,0.8);
			}
			.gf-tooltip-row span:first-child {
				color: rgba(255,255,255,0.5);
			}

			/* Modal styles */
			.modal-overlay {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0,0,0,0.85);
				z-index: 10000;
				align-items: center;
				justify-content: center;
			}

			.modal-overlay.active {
				display: flex;
			}

			.modal-box {
				background: linear-gradient(145deg, var(--theme-bg-gradient-start) 0%, var(--theme-bg-gradient-end) 100%);
				padding: 1.5em;
				border-radius: 20px;
				max-width: 600px;
				max-height: 90vh;
				width: 90%;
				border: 2px solid var(--theme-primary);
				box-shadow: 0 0 30px var(--theme-primary-glow), 0 0 60px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1);
				position: relative;
				overflow-y: auto;
				scrollbar-width: none; /* Firefox */
				-ms-overflow-style: none; /* IE/Edge */
			}

			.modal-box::-webkit-scrollbar {
				display: none; /* Chrome/Safari/Opera */
			}

			/* Responsive modal - scale content to fit screen without scrolling */
			@media (max-height: 950px) {
				#gameModal .modal-box {
					padding: 1.25em;
				}
				#modalImagePreview {
					height: 240px !important;
					margin-bottom: 0.75em !important;
				}
				#gameFaqsInfo {
					padding: 0.5em !important;
					margin-bottom: 0.5em !important;
				}
				#savesButtonRow, #noSavesButtonRow {
					margin-bottom: 0.5em !important;
				}
				#gameModal .modal-box > div:last-of-type {
					padding-top: 0.5em !important;
				}
			}

			@media (max-height: 850px) {
				#gameModal .modal-box {
					padding: 1em;
				}
				#modalImagePreview {
					height: 200px !important;
					margin-bottom: 0.5em !important;
				}
				#gameFaqsInfo {
					padding: 0.4em !important;
					margin-bottom: 0.4em !important;
					font-size: 0.75em !important;
				}
				#savesButtonRow, #noSavesButtonRow {
					margin-bottom: 0.4em !important;
				}
				#savesButtonRow > button:first-child {
					margin-bottom: 0.4em !important;
				}
			}

			@media (max-height: 750px) {
				#gameModal .modal-box {
					padding: 0.75em;
				}
				#modalImagePreview {
					height: 160px !important;
					margin-bottom: 0.4em !important;
				}
				#gameFaqsInfo {
					padding: 0.3em !important;
					margin-bottom: 0.3em !important;
				}
			}

			@media (max-height: 650px) {
				#modalImagePreview {
					height: 120px !important;
				}
			}

			/* Smooth focus outlines */
			select:focus,
			input:focus,
			textarea:focus {
				outline: none;
				border-color: #3b82f6;
				box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
			}

			button,
			button:focus,
			button:active,
			button:hover {
				outline: none !important;
				-webkit-tap-highlight-color: transparent;
			}

			.modal-box .modal-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 1em;
			}

			.modal-box h3 {
				color: #60a5fa;
				margin: 0;
				font-size: 1.1em;
			}

			.modal-box .close-btn {
				background: none !important;
				border: none !important;
				color: #fff;
				cursor: pointer;
				font-size: 1.25em;
				padding: 0 !important;
				opacity: 0.7;
				transition: opacity 0.2s;
				box-shadow: none !important;
				width: auto !important;
				height: auto !important;
				line-height: 1 !important;
			}

			.modal-box .close-btn:before,
			.modal-box .close-btn:after {
				display: none !important;
			}

			.modal-box .close-btn:hover {
				opacity: 1;
				background: none !important;
			}
			/* Game modal specific */
			.game-modal-content {
				display: flex;
				gap: 1em;
			}

			.game-modal-left {
				flex-shrink: 0;
			}

			.game-modal-right {
				flex: 1;
				display: flex;
				flex-direction: column;
				gap: 0.5em;
				min-width: 0;
			}

			.image-preview {
				min-width: 160px;
				min-height: 160px;
				max-width: 200px;
				background: rgba(0,0,0,0.3);
				display: flex;
				align-items: center;
				justify-content: center;
				border-radius: 8px;
				overflow: hidden;
				padding: 8px;
			}

			.image-preview img {
				max-width: 100%;
				max-height: 100%;
				width: auto;
				height: auto;
				object-fit: contain;
				display: block;
				margin: auto;
			}

			#modalImagePreview {
				max-width: 100%;
			}

			#modalImagePreview img {
				max-width: calc(100% - 16px);
				max-height: calc(100% - 16px);
			}

			.compact-field {
				margin-bottom: 0.25em;
			}

			.compact-field label {
				font-size: 0.8em;
				margin-bottom: 0.2em;
				display: block;
				color: rgba(255,255,255,0.7);
			}

			.compact-field input {
				padding: 0.4em 0.6em;
				font-size: 0.85em;
				width: 100%;
				box-sizing: border-box;
			}

			.compact-actions {
				display: flex;
				gap: 0.4em;
				margin-top: 0.25em;
				flex-wrap: wrap;
			}

			.modal-box .google-link {
				color: #60a5fa;
				text-decoration: none;
				font-size: 0.85em;
				margin-left: 0.5em;
			}

			.modal-box .google-link:hover {
				text-decoration: underline;
			}

			/* Image picker modal - fullscreen */
			.image-picker-overlay {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0,0,0,0.9);
				z-index: 10001;
				display: none;
				flex-direction: column;
				padding: 1em;
			}

			.image-picker-overlay.active {
				display: flex;
			}

			.image-picker-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin: -1.5em -1.5em 1em -1.5em;
				padding: 1em 1.5em;
				flex-shrink: 0;
				background: rgba(0, 0, 0, 0.3);
				border-bottom: 1px solid rgba(59, 130, 246, 0.2);
			}

			.image-picker-header h3 {
				color: #60a5fa;
				margin: 0;
			}

			.image-picker-search {
				display: flex;
				gap: 0.5em;
				flex: 1;
				max-width: 500px;
				margin: 0 2em;
				align-items: center;
				flex-wrap: wrap;
			}

			.image-picker-search input {
				flex: 1;
				min-width: 200px;
				height: 2.75em;
				box-sizing: border-box;
			}
			
			.image-picker-search input:focus {
				border-color: var(--theme-primary);
				box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
			}
			
			.image-picker-search select {
				min-width: 140px;
				height: 2.75em;
				box-sizing: border-box;
			}
			

			


			.image-picker-search .styled-btn {
				padding: 0 12px;
				height: 32px;
				font-size: 0.65em;
			}

			.image-picker-close {
				background: none !important;
				border: none !important;
				color: #fff;
				font-size: 2em;
				cursor: pointer;
				opacity: 0.7;
				padding: 0 !important;
				line-height: 1;
				box-shadow: none !important;
				width: auto !important;
				height: auto !important;
			}

			.image-picker-close:hover {
				opacity: 1;
				background: none !important;
			}

			.image-picker-close::before,
			.image-picker-close::after {
				display: none !important;
			}

			.image-picker-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
				gap: 1em;
				overflow-y: auto;
				flex: 1;
				padding: 0.5em;
				align-items: start;
			}

			.image-picker-grid img {
				max-width: 100%;
				width: auto;
				height: auto;
				object-fit: contain;
				border-radius: 8px;
				cursor: pointer;
				border: 3px solid transparent;
				transition: border-color 0.2s, transform 0.2s;
				background: rgba(0,0,0,0.3);
			}

			.image-picker-grid img:hover {
				border-color: #3b82f6;
				transform: scale(1.03);
			}

			.image-picker-grid img.selected {
				border-color: #22c55e;
			}

			.image-picker-grid .loading,
			.image-picker-grid .no-results {
				grid-column: 1 / -1;
				text-align: center;
				color: rgba(255,255,255,0.5);
				padding: 3em;
				font-size: 1.2em;
			}

			.image-picker-footer {
				display: flex;
				justify-content: flex-end;
				align-items: center;
				margin-top: 1em;
				flex-shrink: 0;
				padding-top: 1em;
				border-top: 1px solid #334155;
			}


			.drop-zone {
				border: 3px dashed rgba(37, 99, 235, 0.5);
				border-radius: 10px;
				padding: 2em;
				text-align: center;
				margin-bottom: 1em;
				transition: all 0.3s;
			}

			.drop-zone.dragover {
				border-color: #3b82f6;
				background: rgba(59, 130, 246, 0.1);
			}


			.file-list {
				max-height: 200px;
				overflow-y: auto;
			}

			.file-item {
				display: flex;
				flex-direction: column;
				padding: 0.5em;
				background: rgba(255,255,255,0.05);
				margin-bottom: 5px;
				border-radius: 5px;
			}

			.file-item .original {
				color: rgba(255,255,255,0.4);
				font-size: 0.8em;
			}

			.file-item .clean {
				color: #4ade80;
			}

			.status-msg {
				padding: 0.75em 1em;
				border-radius: 5px;
				margin-top: 1em;
				display: none;
			}

			.status-msg.success {
				background: rgba(74, 222, 128, 0.2);
				color: #4ade80;
				display: block;
			}

			.status-msg.error {
				background: rgba(239, 68, 68, 0.2);
				color: #f87171;
				display: block;
			}

			#sidebar {
				width: 20em;
				overflow-y: auto !important;
				padding: 1em 1.5em 0.5em 1.5em !important;
				height: 100vh !important;
			}

			/* Hide scrollbar but allow scrolling */
			#sidebar::-webkit-scrollbar {
				display: none;
			}

			#sidebar {
				-ms-overflow-style: none;
				scrollbar-width: none;
			}

			#sidebar nav ul {
				max-height: calc(100vh - 180px);
				overflow-y: auto;
				-ms-overflow-style: none;
				scrollbar-width: none;
				padding-bottom: 10px;
				flex-direction: column !important;
			}

			/* Center "Home" when it's the only item */
			#sidebar nav ul:has(li:only-child) {
				display: flex;
				justify-content: center;
				align-items: center;
				min-height: calc(100vh - 180px);
			}

			/* On small heights, reduce space for Theme/Version to give more room for navigation */
			@media screen and (max-height: 600px) {
				#sidebar nav ul {
					max-height: calc(100vh - 120px);
				}

				#sidebar .theme-btn {
					bottom: 35px;
					font-size: 0.85em;
					padding: 8px 12px;
				}
			}

			@media screen and (max-height: 400px) {
				#sidebar nav ul {
					max-height: calc(100vh - 100px);
				}

				#sidebar .theme-btn {
					bottom: 30px;
					font-size: 0.8em;
					padding: 6px 10px;
				}

				#sidebar > .inner > div[style*="bottom: 15px"] {
					font-size: 10px !important;
					bottom: 10px !important;
				}
			}

			#sidebar nav ul::-webkit-scrollbar {
				display: none;
			}

			#sidebar > .inner {
				padding-bottom: 80px;
				min-height: 100% !important;
				height: 100% !important;
				justify-content: flex-start !important;
				padding-top: 0 !important;
				transform: none !important;
				flex-direction: column !important;
				display: flex !important;
			}

			/* Ultrawide monitor support - expand games section */
			#games > .inner {
				width: 100%;
				max-width: none;
			}

			@media screen and (max-width: 1280px) {
				#sidebar {
					width: 18em;
				}
			}

			@media screen and (max-width: 980px) {
				#sidebar {
					width: 16em;
				}

				#sidebar > .inner {
					padding: 1em;
				}

				#sidebar .theme-btn {
					font-size: 0.9em;
					padding: 8px 12px;
				}
			}

			@media screen and (max-width: 736px) {
				#sidebar {
					width: 14em;
					font-size: 0.9em;
				}

				#sidebar nav ul li a {
					padding: 0.5em 0.8em;
					font-size: 0.85em;
				}

				#sidebar nav ul li .game-count,
				#sidebar nav ul li .missing-art-count {
					font-size: 0.75em;
					padding: 2px 6px;
				}

				#sidebar .theme-btn {
					font-size: 0.85em;
					padding: 6px 10px;
					bottom: 40px;
				}

				#sidebar > .inner > div[style*="bottom: 15px"] {
					font-size: 10px !important;
				}

				.games-grid {
					grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
				}
			}

			@media screen and (max-width: 480px) {
				#sidebar {
					width: 12em;
					font-size: 0.85em;
				}

				#sidebar nav ul li a {
					padding: 0.4em 0.6em;
					font-size: 0.8em;
				}

				#sidebar nav ul li img.console-icon {
					width: 18px;
					height: 18px;
				}

				#sidebar .theme-btn {
					font-size: 0.75em;
					padding: 5px 8px;
					bottom: 35px;
				}

				.games-grid {
					grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
				}
			}

			/* Floating upload button */
			.floating-upload {
				position: fixed;
				top: 20px;
				right: 20px;
				z-index: 1000;
				display: none;
			}
			.floating-upload.visible {
				display: inline-flex;
			}

			/* Floating install PWA button - small, bottom right, only on intro */
			.floating-install {
				position: fixed;
				bottom: 10px;
				right: 10px;
				z-index: 1000;
				font-size: 0.5em;
				padding: 0.4em 0.6em;
			}

			/* Modern Hero Section */
			.hero-section {
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				text-align: center;
				min-height: 100vh;
				padding: 2em;
			}

			.hero-logo {
				width: 700px;
				max-width: 90vw;
				height: auto;
				margin-bottom: 1.5em;
				filter: drop-shadow(0 15px 40px rgba(59, 130, 246, 0.4));
				animation: float 3s ease-in-out infinite;
			}

			@keyframes float {
				0%, 100% { transform: translateY(0); }
				50% { transform: translateY(-12px); }
			}

			.hero-tagline {
				font-size: 0.95em;
				color: rgba(255, 255, 255, 0.6);
				max-width: 400px;
				margin: 0 auto 1.5em auto;
				line-height: 1.5;
			}

			/* Browser Requirements Section */
			.browser-requirements {
				margin-top: 2em;
				padding: 1.5em 2em;
				background: linear-gradient(135deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.02) 100%);
				border: 1px solid rgba(255,255,255,0.1);
				border-radius: 16px;
				max-width: 400px;
				margin-left: auto;
				margin-right: auto;
				backdrop-filter: blur(10px);
				overflow: visible;
			}

			.browser-req-title {
				font-size: 0.8em;
				font-weight: 600;
				text-transform: uppercase;
				letter-spacing: 1.5px;
				color: rgba(255,255,255,0.5);
				margin-bottom: 0.5em;
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 0.5em;
			}

			.browser-req-title .icon {
				color: #22c55e;
			}

			.browser-icons {
				display: flex;
				justify-content: center;
				gap: 2em;
				margin-bottom: 1em;
				padding: 1em 0;
				overflow: visible;
			}

			.browser-icon {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 0.5em;
				opacity: 0.8;
				transition: all 0.2s ease;
				cursor: default;
				overflow: visible;
			}

			.browser-icon:hover {
				opacity: 1;
				transform: translateY(-3px);
			}

			.browser-icon img {
				display: block;
				border-radius: 8px;
			}

			.browser-icon span {
				font-size: 0.7em;
				font-weight: 500;
				text-transform: uppercase;
				letter-spacing: 1px;
				color: rgba(255,255,255,0.6);
			}

			.browser-req-note {
				font-size: 0.75em;
				color: rgba(255,255,255,0.4);
				display: flex;
				align-items: center;
				justify-content: center;
				gap: 0.5em;
			}

			.browser-req-note .icon {
				color: var(--theme-primary, #3b82f6);
			}

			.hero-stats {
				display: flex;
				gap: 3em;
				margin-top: 3em;
				justify-content: center;
				flex-wrap: wrap;
			}

			.hero-stat {
				text-align: center;
			}

			.hero-stat.clickable {
				cursor: pointer;
				padding: 1em 1.5em;
				border-radius: 12px;
				transition: all 0.2s ease;
			}

			.hero-stat.clickable:hover {
				background: rgba(255, 255, 255, 0.1);
				transform: translateY(-2px);
			}

			.hero-stat.clickable:hover .value {
				color: #93c5fd;
				text-shadow: 0 0 20px rgba(96, 165, 250, 0.5);
			}

			.hero-stat .value {
				font-size: 2.5em;
				font-weight: 700;
				color: #60a5fa;
				line-height: 1;
				transition: all 0.2s ease;
			}

			.hero-stat .label {
				font-size: 0.85em;
				color: rgba(255, 255, 255, 0.5);
				text-transform: uppercase;
				letter-spacing: 1px;
				margin-top: 0.5em;
			}

			.footer-content {
				display: flex;
				align-items: center;
				gap: 12px;
				justify-content: center;
			}

			.footer-logo {
				width: 50px;
				height: auto;
				opacity: 0.7;
				transition: opacity 0.3s;
			}

			.footer-logo:hover {
				opacity: 1;
			}

			.footer-text {
				font-size: 0.9em;
				opacity: 0.6;
			}

			#footer .version-number {
				position: fixed;
				bottom: 10px;
				left: 10px;
				font-size: 0.8em;
				color: rgba(255, 255, 255, 0.6);
				z-index: 100;
			}

			@media screen and (max-width: 736px) {
				.hero-logo {
					width: 320px;
				}
				.hero-stats {
					gap: 2em;
				}
			}

			/* Apply intro background stripes to games section */
			#games {
				background-attachment: fixed;
				background-image: url("assets/css/images/intro.svg");
				background-position: top right;
				background-repeat: no-repeat;
				background-size: 100% 100%;
			}

			@media screen and (max-width: 1280px) {
				#games {
					background-attachment: scroll;
				}
			}

			/* Filter and Sort Controls */
			.search-input {
				height: 2.75em;
				box-sizing: border-box;
			}

			
			/* Game count badge in header */
			.console-header {
				display: flex;
				align-items: center;
				gap: 0.75em;
				flex-wrap: wrap;
			}

			.console-header-icon {
				width: 48px;
				height: 48px;
				object-fit: contain;
			}

			.console-header h2 {
				font-family: 'Press Start 2P', cursive;
				font-size: 0.9em;
				text-shadow: 0 0 8px rgba(96, 165, 250, 0.6), 0 0 15px rgba(59, 130, 246, 0.4);
			}

			.game-count-badge {
				background: rgba(59, 130, 246, 0.2);
				color: #60a5fa;
				padding: 4px 12px;
				border-radius: 20px;
				font-size: 0.5em;
				font-weight: 500;
			}

			.game-count-badge .missing {
				color: #fbbf24;
				margin-left: 8px;
			}


			/* Right-click context menu */
			.context-menu {
				position: fixed;
				background: #1e293b;
				border: 1px solid var(--theme-primary);
				border-radius: 8px;
				box-shadow: 0 10px 40px rgba(0,0,0,0.5);
				z-index: 10002;
				min-width: 180px;
				padding: 6px 0;
				display: none;
			}

			.context-menu.active {
				display: block;
			}

			.context-menu-item {
				display: flex;
				align-items: center;
				gap: 10px;
				padding: 10px 16px;
				color: #fff;
				cursor: pointer;
				font-size: 0.85em;
				transition: background 0.2s;
			}

			.context-menu-item:hover {
				background: var(--theme-primary-glow);
			}

			.context-menu-item .icon {
				color: var(--theme-primary-light);
				width: 16px;
				text-align: center;
			}

			.context-menu-item.danger {
				color: #f87171;
			}

			.context-menu-item.danger .icon {
				color: #f87171;
			}

			.context-menu-divider {
				height: 1px;
				background: rgba(255,255,255,0.1);
				margin: 6px 0;
			}

			/* Device selector grid */
			.device-grid {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
				gap: 0.75em;
			}

			.device-card {
				background: rgba(255,255,255,0.05);
				border: 2px solid rgba(255,255,255,0.1);
				border-radius: 12px;
				padding: 1em 0.75em;
				text-align: center;
				cursor: pointer;
				transition: all 0.2s ease;
			}

			.device-card:hover {
				background: var(--theme-primary-glow);
				border-color: var(--theme-primary);
				transform: translateY(-3px);
			}

			.device-card .device-icon {
				font-size: 2.5em;
				margin-bottom: 0.5em;
			}

			.device-card .device-image {
				width: 65px;
				height: 65px;
				object-fit: contain;
				margin-bottom: 0.35em;
				border-radius: 8px;
			}

			.device-card .device-name {
				font-weight: 600;
				color: #fff;
				margin-bottom: 0.15em;
				font-size: 0.95em;
			}

			.device-card .device-desc {
				font-size: 0.7em;
				color: rgba(255,255,255,0.5);
			}

			/* Current device indicator in sidebar */
			.current-device {
				display: flex;
				align-items: center;
				gap: 8px;
				padding: 8px 12px;
				background: var(--theme-primary-glow);
				border-radius: 8px;
				margin-bottom: 1em;
				font-size: 0.85em;
				color: var(--theme-primary-light);
				cursor: pointer;
				transition: background 0.2s;
			}

			.current-device:hover {
				background: var(--theme-primary-glow);
				filter: brightness(1.2);
			}

			.current-device .device-emoji {
				font-size: 1.2em;
			}

			/* Theme selector button */
			.theme-btn {
				display: flex;
				align-items: center;
				gap: 8px;
				padding: 8px 12px;
				background: rgba(255,255,255,0.05);
				border: 1px solid rgba(255,255,255,0.1);
				border-radius: 8px;
				margin-top: 0.5em;
				font-size: 0.85em;
				color: rgba(255,255,255,0.7);
				cursor: pointer;
				transition: all 0.2s;
			}

			.theme-btn:hover {
				background: var(--theme-primary-glow);
				border-color: var(--theme-primary);
				color: #fff;
			}

			/* Theme grid */
			.theme-grid {
				display: grid;
				grid-template-columns: repeat(4, 1fr);
				gap: 1em;
			}

			.theme-card {
				background: rgba(255,255,255,0.05);
				border: 2px solid rgba(255,255,255,0.1);
				border-radius: 12px;
				padding: 1.25em 1em 1em 1em;
				text-align: center;
				cursor: pointer;
				transition: all 0.2s ease;
				overflow: hidden;
			}

			.theme-card:hover {
				transform: translateY(-3px);
			}

			.theme-card.active {
				border-color: #fff;
				box-shadow: 0 0 20px rgba(255,255,255,0.2);
			}

			.theme-card .theme-preview {
				width: 45px;
				height: 45px;
				border-radius: 50%;
				margin: 0 auto 0.5em;
				box-shadow: 0 4px 15px rgba(0,0,0,0.3);
			}

			.theme-card .theme-name {
				font-size: 0.75em;
				color: #fff;
				font-weight: 500;
			}

			/* Theme preview colors */
			.theme-preview.blue { background: linear-gradient(135deg, #3b82f6, #1d4ed8); }
			.theme-preview.purple { background: linear-gradient(135deg, #8b5cf6, #6d28d9); }
			.theme-preview.green { background: linear-gradient(135deg, #22c55e, #15803d); }
			.theme-preview.red { background: linear-gradient(135deg, #ef4444, #b91c1c); }
			.theme-preview.cyan { background: linear-gradient(135deg, #06b6d4, #0891b2); }
			.theme-preview.orange { background: linear-gradient(135deg, #f59e0b, #d97706); }
			.theme-preview.pink { background: linear-gradient(135deg, #ec4899, #be185d); }

			@media screen and (max-width: 600px) {
				.theme-grid {
					grid-template-columns: repeat(3, 1fr);
				}
			}

			@media screen and (max-width: 900px) {
				#deviceModal .modal-box {
					max-width: 500px !important;
				}

				.device-grid {
					grid-template-columns: repeat(2, 1fr);
					gap: 0.5em;
				}

				.device-card .device-image {
					width: 55px;
					height: 55px;
				}

				.device-card {
					padding: 0.75em 0.5em;
				}

				.device-card .device-name {
					font-size: 0.85em;
				}

				.device-card .device-desc {
					font-size: 0.65em;
				}
			}

			@media screen and (max-width: 600px) {
				.device-grid {
					grid-template-columns: 1fr;
				}

				.device-card .device-image {
					width: 80px;
					height: 80px;
				}
				
				.image-picker-search {
					flex-direction: column;
					margin: 0 1em;
					align-items: stretch !important;
				}
				
				.image-picker-search > div {
					width: 100%;
					display: flex;
					gap: 0.5em;
					align-items: center;
					margin-bottom: 0.5em;
				}
				
				.image-picker-search select {
					width: 100%;
					margin-bottom: 0.5em;
					min-width: auto;
				}
				
				.image-picker-search input {
					width: 100%;
					margin-bottom: 0.5em;
				}
			}

			/* Button press animation synced with logo float (3s cycle) */
			/* Logo: 0%=bottom, 50%=top, 100%=bottom */
			/* Button: 0%=pressed, 50%=raised, 100%=pressed */
			@keyframes button-press {
				0%, 100% {
					transform: skew(-10deg) translateY(4px);
					box-shadow: 0 2px 0 var(--btn-shadow);
				}
				50% {
					transform: skew(-10deg) translateY(0);
					box-shadow: 0 6px 0 var(--btn-shadow);
				}
			}

			@keyframes pulse-glow {
				0%, 100% { box-shadow: 0 0 0 8px rgba(139, 92, 246, 0.3); }
				50% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0); }
			}

			.pulse-attention {
				position: relative;
				animation: button-press 3s ease-in-out infinite;
			}

			.pulse-attention::before {
				content: '';
				position: absolute;
				inset: 0;
				border-radius: inherit;
				animation: pulse-glow 3s ease-in-out infinite;
				pointer-events: none;
			}

			@keyframes pulse {
				0%, 100% {
					transform: scale(1);
					box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7);
				}
				50% {
					transform: scale(1.05);
					box-shadow: 0 0 20px 10px rgba(139, 92, 246, 0);
				}
			}

			/* Mobile Menu Toggle Button */
			.mobile-menu-toggle {
				display: none;
				position: static;
				background: var(--theme-sidebar-bg);
				border: none;
				border-radius: 8px;
				width: 50px;
				height: 50px;
				cursor: pointer;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
				transition: all 0.3s ease;
				margin: 20px;
			}

			.mobile-menu-toggle .icon {
				color: rgba(255, 255, 255, 0.8);
				font-size: 1.5em;
			}

			.mobile-menu-toggle:hover {
				background: var(--theme-primary);
				transform: scale(1.05);
			}

			.mobile-menu-toggle:active {
				transform: scale(0.95);
			}

			/* Mobile Menu Overlay */
			.mobile-menu-overlay {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: var(--theme-sidebar-bg);
				z-index: 10000;
				opacity: 0;
				transition: opacity 0.3s ease;
				overflow-y: auto;
				padding: 80px 20px 20px;
			}

			.mobile-menu-overlay.active {
				display: block;
				opacity: 1;
			}

			.mobile-menu-overlay nav ul {
				list-style: none;
				padding: 0;
				margin: 0;
			}

			.mobile-menu-overlay nav ul li {
				margin-bottom: 0;
				border-bottom: 1px solid rgba(255, 255, 255, 0.1);
			}

			.mobile-menu-overlay nav ul li a {
				display: flex;
				align-items: center;
				gap: 12px;
				padding: 16px 12px;
				color: rgba(255, 255, 255, 0.8);
				text-decoration: none;
				font-size: 16px;
				transition: background 0.2s ease;
			}

			.mobile-menu-overlay nav ul li a:hover,
			.mobile-menu-overlay nav ul li a:active {
				background: rgba(255, 255, 255, 0.1);
				color: rgba(255, 255, 255, 1);
			}

			.mobile-menu-overlay nav ul li img {
				width: 32px;
				height: 32px;
			}

			.mobile-menu-overlay .game-count,
			.mobile-menu-overlay .missing-art-count {
				margin-left: auto;
				font-size: 14px;
				padding: 4px 8px;
				border-radius: 4px;
			}

			.mobile-menu-overlay .game-count {
				background: rgba(34, 211, 238, 0.2);
				color: #22d3ee;
			}

			.mobile-menu-overlay .missing-art-count {
				background: rgba(239, 68, 68, 0.2);
				color: #ef4444;
			}

			.mobile-menu-footer {
				margin-top: 30px;
				padding-top: 20px;
				border-top: 1px solid rgba(255, 255, 255, 0.1);
				text-align: center;
			}

			/* Batch loading overlay */
			.batch-loading-overlay {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				background: rgba(0, 0, 0, 0.8);
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				z-index: 100;
				border-radius: 10px 10px 0 0;
			}

			.batch-spinner {
				width: 30px;
				height: 30px;
				border: 3px solid rgba(255, 255, 255, 0.1);
				border-top-color: #8b5cf6;
				border-radius: 50%;
				animation: spin 1s linear infinite;
				margin-bottom: 8px;
			}

			.batch-loading-text {
				color: #fff;
				font-size: 0.75em;
				text-align: center;
			}

			/* Show menu toggle on small screens */
			@media screen and (max-width: 1292px) {
				.mobile-menu-toggle {
					display: flex;
					align-items: center;
					justify-content: center;
				}

				/* Hide desktop sidebar completely */
				#sidebar {
					display: none !important;
				}

				/* Change icon when menu is open */
				body.mobile-menu-open .mobile-menu-toggle .fa-bars::before {
					content: '\f00d'; /* fa-times */
				}
			}

		</style>
	</head>
	<body class="is-preload">

		<!-- Mobile Menu Toggle -->
		<button class="mobile-menu-toggle" id="mobileMenuToggle" onclick="toggleMobileMenu()">
			<span class="icon solid fa-bars"></span>
		</button>

		<!-- Mobile Menu Overlay -->
		<div class="mobile-menu-overlay" id="mobileMenuOverlay">
			<div style="display: flex; justify-content: flex-end; align-items: center; padding: 0 20px 20px;">
				<button class="btn-3d red" onclick="toggleMobileMenu();">
					<span class="icon solid fa-times"></span> Close
				</button>
			</div>
			<nav>
				<ul id="mobileConsoleList">
					<!-- Populated by JavaScript -->
				</ul>
			</nav>
			<div class="mobile-menu-footer">
				<button class="btn-3d purple" onclick="showThemeSelector(); toggleMobileMenu();" style="margin-bottom: 10px;">
					<span class="icon solid fa-palette"></span> Theme
				</button>
				<div style="font-size: 12px; color: rgba(255,255,255,0.5); font-style: italic;">Version 1.6</div>
			</div>
		</div>

		<!-- Floating Upload Button -->
		<button class="btn-3d green floating-upload" id="floatingUpload" onclick="openUploadModal()">
			<span class="icon solid fa-upload"></span> Upload
		</button>

		<!-- Floating Install PWA Button -->
		<button class="btn-3d green floating-install" id="installPwaBtn" style="display: none;" onclick="installPwa()">
			<span class="icon solid fa-download"></span> Install App
		</button>

		<!-- Sidebar -->
		<section id="sidebar">
			<div class="inner">
				<nav>
					<ul id="consoleList">
						<li><a href="#intro">Home</a></li>
					</ul>
				</nav>
				<div class="theme-btn" onclick="showThemeSelector()" style="position: absolute; bottom: 45px; left: 15px; right: 15px;">
					<span class="icon solid fa-palette"></span> Theme
				</div>
				<div style="position: absolute; bottom: 15px; left: 15px; font-size: 12px; color: rgba(255,255,255,0.5); font-style: italic;">Version 1.6</div>
			</div>
		</section>

		<!-- Wrapper -->
		<div id="wrapper">

			<!-- Intro -->
			<section id="intro" class="wrapper style1 fullscreen fade-up">
				<div class="hero-section">
					<img src="assets/images/logo.png" alt="NanoArcade" class="hero-logo">
					<p class="hero-tagline">Your retro game collection, beautifully organized. Browse by console, manage box art, and keep your library sharp.</p>
					<div style="display: flex; gap: 1em; justify-content: center; flex-wrap: wrap;">
						<button class="btn-3d purple pulse-attention" id="selectDeviceBtn" onclick="showDeviceSelector()">
							<span class="icon solid fa-gamepad"></span> Select Device
						</button>
					</div>
					<div class="browser-requirements">
						<div class="browser-req-title">
							<span class="icon solid fa-check-circle"></span> Supported Browsers
						</div>
						<div class="browser-icons">
							<div class="browser-icon" title="Google Chrome">
								<img src="assets/images/browsers/chrome.png" alt="Chrome" width="36" height="36">
								<span>Chrome</span>
							</div>
							<div class="browser-icon" title="Microsoft Edge">
								<img src="assets/images/browsers/edge.png" alt="Edge" width="36" height="36">
								<span>Edge</span>
							</div>
							<div class="browser-icon" title="Opera">
								<img src="assets/images/browsers/opera.png" alt="Opera" width="36" height="36">
								<span>Opera</span>
							</div>
						</div>
						<div class="browser-req-note">
							<span class="icon solid fa-folder-open"></span> File access permission required
						</div>
					</div>
					<div class="hero-stats" id="statsRow" style="display:none;">
						<div class="hero-stat clickable" style="cursor: default; pointer-events: none;">
							<div class="value" id="statConsoles">0</div>
							<div class="label">Consoles</div>
						</div>
						<div class="hero-stat clickable" onclick="goToAllGames(false)" title="View all games">
							<div class="value" id="statGames">0</div>
							<div class="label">Games</div>
						</div>
						<div class="hero-stat clickable" onclick="goToAllGames(true)" title="View games missing art">
							<div class="value" id="statMissing">0</div>
							<div class="label">Missing Art</div>
						</div>
					</div>
					<!-- Buy Me a Coffee -->
					<div style="margin-top: 2em;">
						<a href="https://space.bilibili.com/6607288" target="_blank" rel="noopener"><img src="https://img.buymeacoffee.com/button-api/?text=Follow my Bilibili&emoji=ðŸ“º&slug=audioslayer&button_colour=FF6699&font_colour=ffffff&font_family=Cookie&outline_colour=000000&coffee_colour=FFDD00" alt="Follow my Bilibili" /></a>
					</div>
				</div>
			</section>

			<!-- Games Section -->
			<section id="games" class="wrapper style1 fade-up" style="display:none;">
				<div class="inner">
					<div class="console-header">
						<img id="currentConsoleIcon" class="console-header-icon" src="" alt="" style="display:none;">
						<h2 id="currentConsoleName">Select a console to view games</h2>
						<span class="game-count-badge" id="gameCountBadge" style="display:none;">
							<span id="totalGameCount">0</span> games
							<span class="missing" id="missingArtCount" style="display:none;">(<span id="missingCount">0</span> missing art)</span>
						</span>
					</div>
					<div class="controls-bar">
						<input type="text" id="searchBox" class="search-input" placeholder="Search games..." oninput="filterGames()">
						<button class="btn-3d small cyan" id="filterMissingBtn" onclick="toggleMissingFilter()">
							<span class="icon solid fa-filter"></span> Missing Art
						</button>
						<button class="btn-3d small purple" id="batchLibretroBtn" onclick="batchFetchLibretroImages()" style="display:none;" title="Fetch all missing art from Libretro">
							<span class="icon solid fa-download"></span> Libretro
						</button>
						<button class="btn-3d small gold" id="top25Btn" onclick="openTop25Modal()" style="display:none;">
							<span class="icon solid fa-trophy"></span> Top 25
						</button>
						<button class="btn-3d small gray" id="sortBtn" onclick="toggleSort()">
							<span class="icon solid fa-sort-alpha-down" id="sortIcon"></span> <span id="sortLabel">A-Z</span>
						</button>
					</div>
					<div class="games-grid" id="gamesGrid">
						<p>Scan your drive to view games</p>
					</div>
				</div>
			</section>

		</div>

		<!-- Game Modal -->
		<div class="modal-overlay" id="gameModal">
			<div class="modal-box" style="max-width: 550px;">
				<!-- Header -->
				<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1em; gap: 0.5em;">
					<div style="display: flex; align-items: center; gap: 0.5em; min-width: 0; flex: 1;">
						<div id="gameTitleWrap" style="position: relative; min-width: 0; flex: 1; cursor: default;">
							<h3 id="modalGameName" style="color: #ffffff; margin: 0; font-family: 'Press Start 2P', cursive; font-size: 0.55em; text-shadow: 0 0 8px #3b82f6, 0 0 15px #3b82f6; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">Game Name</h3>
							<div id="gameTitleTooltip" class="gf-tooltip" style="bottom: auto; top: 100%; margin-top: 0.5em; margin-bottom: 0;"></div>
						</div>
						<span class="icon solid fa-pencil-alt" onclick="openRenameFromGameModal()" style="color: rgba(255,255,255,0.4); cursor: pointer; font-size: 0.8em; flex-shrink: 0;" title="Rename game"></span>
					</div>
					<button class="close-btn" style="flex-shrink: 0;" onclick="closeModal('gameModal')">&times;</button>
				</div>
				<!-- Image preview -->
				<div class="image-preview" id="modalImagePreview" style="
					width: 100%;
					height: 340px;
					margin-bottom: 1.25em;
					border-radius: 12px;
					border: 1px solid rgba(59, 130, 246, 0.3);
					box-shadow: inset 0 0 30px rgba(0,0,0,0.5);
					display: flex;
					align-items: center;
					justify-content: center;
				">
					<span class="no-image">?</span>
				</div>
				<!-- GameFAQs Info -->
				<div id="gameFaqsInfo" style="display: none; margin-bottom: 1em; padding: 0.75em; background: rgba(0,0,0,0.3); border-radius: 8px; border: 1px solid rgba(59, 130, 246, 0.2);">
					<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5em; text-align: center; font-size: 0.8em;">
						<div id="gfRatingWrap" style="cursor: help; position: relative;">
							<div style="color: rgba(255,255,255,0.5); margin-bottom: 0.25em;">Rating</div>
							<div id="gfRating" style="color: #fbbf24;">
								<span class="icon solid fa-star"></span> --
							</div>
							<div id="gfRatingTooltip" class="gf-tooltip"></div>
						</div>
						<div id="gfDifficultyWrap" style="cursor: help; position: relative;">
							<div style="color: rgba(255,255,255,0.5); margin-bottom: 0.25em;">Difficulty</div>
							<div id="gfDifficulty" style="color: #f87171;">
								<span class="icon solid fa-heartbeat"></span> --
							</div>
							<div id="gfDifficultyTooltip" class="gf-tooltip"></div>
						</div>
						<div id="gfLengthWrap" style="cursor: help; position: relative;">
							<div style="color: rgba(255,255,255,0.5); margin-bottom: 0.25em;">Length</div>
							<div id="gfLength" style="color: #34d399;">
								<span class="icon solid fa-clock"></span> --
							</div>
							<div id="gfLengthTooltip" class="gf-tooltip"></div>
						</div>
					</div>
				</div>
				<!-- RG Nano layout: Find Art full width, then Saves + Local Image -->
				<div id="savesButtonRow" style="display: none; margin-bottom: 0.75em;">
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5em; margin-bottom: 0.75em;">
						<button class="btn-3d small" onclick="openImagePicker()"><span class="icon solid fa-search"></span> Find Art</button>
						<button class="btn-3d small gold" onclick="downloadLibretroByCRC()" title="Download artwork from Libretro based on CRC32"><span class="icon solid fa-download"></span> Libretro</button>
					</div>
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5em;">
						<button class="btn-3d small cyan" onclick="openSaveManager()"><span class="icon solid fa-save"></span> Manage Saves</button>
						<button class="btn-3d small gray" onclick="selectLocalImage()"><span class="icon solid fa-folder-open"></span> Local Image</button>
					</div>
				</div>
				<!-- Non-RG Nano layout: Find Art + Local Image side by side -->
				<div id="noSavesButtonRow" style="display: grid; grid-template-columns: 1fr 1.2fr 1.3fr; gap: 0.4em; margin-bottom: 0.75em;">
					<button class="btn-3d small" onclick="openImagePicker()"><span class="icon solid fa-search"></span> Find Art</button>
					<button class="btn-3d small gold" onclick="downloadLibretroByCRC()" title="Download artwork from Libretro based on CRC32"><span class="icon solid fa-download"></span> Libretro</button>
					<button class="btn-3d small gray" onclick="selectLocalImage()"><span class="icon solid fa-folder-open"></span> Local Image</button>
				</div>
				<!-- URL input section -->
				<div style="margin-bottom: 0.75em;">
					<div style="display: flex; gap: 0.5em;">
						<div style="flex: 1; position: relative; display: flex; align-items: center;">
							<span class="icon solid fa-link" style="position: absolute; left: 0.75em; color: rgba(255,255,255,0.4); font-size: 0.85em;"></span>
							<input type="url" id="imageUrl" class="url-input" placeholder="Paste link here..." style="border-color: rgba(59, 130, 246, 0.3); padding-left: 2.25em; padding-right: 2.5em; width: 100%; box-sizing: border-box;">
							<span class="icon brands fa-google" onclick="openGoogleImages()" style="position: absolute; right: 0.75em; color: rgba(255,255,255,0.5); font-size: 0.95em; cursor: pointer; transition: color 0.2s;" onmouseover="this.style.color='#60a5fa'" onmouseout="this.style.color='rgba(255,255,255,0.5)'" title="Search Google Images"></span>
						</div>
						<button class="btn-3d small green" onclick="downloadAndResizeImage()"><span class="icon solid fa-check"></span></button>
					</div>
					<div class="status-msg" id="imageStatus" style="font-size: 0.8em; margin-top: 0.35em;"></div>
				</div>
				<!-- Navigation & Delete -->
				<div style="display: flex; gap: 0.5em; padding-top: 0.75em; border-top: 1px solid rgba(59, 130, 246, 0.2);">
					<button class="btn-3d small purple" id="nextGameBtn" style="flex: 1;" onclick="goToNextMissingArt()"><span class="icon solid fa-forward"></span> Next Missing</button>
					<button class="btn-3d small red" onclick="confirmDeleteGame()"><span class="icon solid fa-trash"></span></button>
				</div>
				<input type="file" id="localImageInput" accept="image/*" style="display:none;" onchange="handleLocalImage(event)">
			</div>
		</div>

		<!-- Top 25 Games Modal -->
		<div class="modal-overlay" id="top25Modal">
			<div class="modal-box" style="max-width: 550px;">
				<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1em;">
					<h3 style="color: #f59e0b; font-size: 1.1em; margin: 0; text-shadow: 0 0 20px rgba(245, 158, 11, 0.5);">
						<span class="icon solid fa-trophy" style="margin-right: 0.5em;"></span>Top 25 <span id="top25ConsoleName">Games</span>
					</h3>
					<button class="close-btn" onclick="closeModal('top25Modal')">&times;</button>
				</div>
				<div style="margin-bottom: 1em; display: flex; gap: 1em; align-items: center;">
					<div class="top25-stats">
						<span style="color: #22c55e;"><span class="icon solid fa-check"></span> <span id="top25Owned">0</span> owned</span>
						<span style="color: #ef4444; margin-left: 1em;"><span class="icon solid fa-times"></span> <span id="top25Missing">0</span> missing</span>
					</div>
				</div>
				<div id="top25List" style="max-height: 400px; overflow-y: auto; margin: 0 -1em; padding: 0 1em;"></div>
				<div class="top25-upload-zone" id="top25DropZone" style="margin-top: 1em; border: 2px dashed rgba(245, 158, 11, 0.4); border-radius: 8px; padding: 1em; text-align: center; transition: all 0.2s;">
					<span class="icon solid fa-cloud-upload-alt" style="font-size: 1.5em; color: #f59e0b; margin-bottom: 0.5em; display: block;"></span>
					<p style="margin: 0; font-size: 0.85em; color: rgba(255,255,255,0.6);">Drag & drop missing ROMs here or <a href="#" onclick="document.getElementById('top25FileInput').click(); return false;" style="color: #f59e0b;">browse</a></p>
				</div>
				<input type="file" id="top25FileInput" multiple style="display:none;" onchange="handleTop25Upload(event)">
			</div>
		</div>

		<!-- Upload Modal -->
		<div class="modal-overlay" id="uploadModal">
			<div class="modal-box" style="max-width: 480px;">
				<!-- Header with neon accent -->
				<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.25em;">
					<h3 style="color: #60a5fa; font-size: 1.1em; margin: 0; text-shadow: 0 0 20px rgba(96, 165, 250, 0.5);">
						<span class="icon solid fa-upload" style="margin-right: 0.5em;"></span>Upload Games
					</h3>
					<button class="close-btn" onclick="closeModal('uploadModal')">&times;</button>
				</div>
				<!-- Console selector -->
				<div style="margin-bottom: 1em;">
					<label style="font-size: 0.8em; color: rgba(255,255,255,0.5); margin-bottom: 0.35em; display: block;">Target Console</label>
					<select id="uploadConsoleSelect" style="width: 100%; background-color: rgba(0,0,0,0.3); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 10px; color: white;">
						<option value="">Select a console...</option>
					</select>
				</div>
				<!-- Drop zone -->
				<div class="drop-zone" id="dropZone" onclick="document.getElementById('fileInput').click()" style="
					border: 2px dashed rgba(59, 130, 246, 0.4);
					border-radius: 12px;
					padding: 1.75em;
					text-align: center;
					background: rgba(0,0,0,0.3);
					margin-bottom: 1em;
					transition: all 0.2s;
					cursor: pointer;
				">
					<span class="icon solid fa-file-import" style="font-size: 2em; color: #3b82f6; margin-bottom: 0.5em; display: block; text-shadow: 0 0 15px rgba(59, 130, 246, 0.5);"></span>
					<p style="color: rgba(255,255,255,0.7); font-size: 0.9em; margin-bottom: 0.25em;">Drag & drop ROM files</p>
					<p style="color: rgba(255,255,255,0.4); font-size: 0.75em;">or click to browse</p>
					<input type="file" id="fileInput" multiple style="display:none;" onchange="handleFileSelect(event)">
				</div>
				<!-- File list -->
				<div class="file-list" id="fileList" style="max-height: 120px; overflow-y: auto; margin-bottom: 1em; display: flex; flex-direction: column; gap: 0.4em;"></div>
				<!-- Action buttons -->
				<div style="display: flex; gap: 0.5em; padding-top: 0.75em; border-top: 1px solid rgba(59, 130, 246, 0.2);">
					<button class="btn-3d small gray" style="flex: 0.4;" onclick="closeModal('uploadModal')"><span class="icon solid fa-times"></span> Cancel</button>
					<button class="btn-3d small green" style="flex: 0.6;" onclick="uploadFiles()"><span class="icon solid fa-upload"></span> Upload</button>
				</div>
				<div class="status-msg" id="uploadStatus" style="margin-top: 0.5em;"></div>
			</div>
		</div>

		<!-- Delete Confirmation Modal -->
		<div class="modal-overlay" id="deleteModal">
			<div class="modal-box" style="max-width: 400px;">
				<div class="modal-header">
					<h3 style="color: #ef4444;"><span class="icon solid fa-exclamation-triangle"></span> Delete Game</h3>
					<button class="close-btn" onclick="closeModal('deleteModal')">&times;</button>
				</div>
				<p id="deleteConfirmText" style="margin-bottom: 1.5em; text-align: center;">Are you sure you want to delete this game?</p>
				<div style="display: flex; gap: 1em; justify-content: center;">
					<button class="btn-3d small gray" onclick="closeModal('deleteModal')"><span class="icon solid fa-times"></span> Cancel</button>
					<button class="btn-3d small red" onclick="executeDeleteGame()"><span class="icon solid fa-trash"></span> Delete</button>
				</div>
			</div>
		</div>

		<!-- Delete Save Confirmation Modal -->
		<div class="modal-overlay" id="deleteSaveModal" style="z-index: 10001;">
			<div class="modal-box" style="max-width: 400px;">
				<div class="modal-header">
					<h3 style="color: #ef4444;"><span class="icon solid fa-exclamation-triangle"></span> Delete Save</h3>
					<button class="close-btn" onclick="closeModal('deleteSaveModal')">&times;</button>
				</div>
				<p id="deleteSaveConfirmText" style="margin-bottom: 1.5em; text-align: center;">Are you sure you want to delete this save?</p>
				<div style="display: flex; gap: 1em; justify-content: center;">
					<button class="btn-3d small gray" onclick="closeModal('deleteSaveModal')"><span class="icon solid fa-times"></span> Cancel</button>
					<button class="btn-3d small red" onclick="executeDeleteSave()"><span class="icon solid fa-trash"></span> Delete</button>
				</div>
			</div>
		</div>

		<!-- Image Picker Modal (fullscreen) -->
		<div class="image-picker-overlay" id="imagePicker">
			<div class="image-picker-header">
				<h3>Select Box Art</h3>
				<div class="image-picker-search">
					<div style="display: flex; gap: 0.5em; align-items: center; margin-bottom: 0.5em;">
						<label for="pickerSearchSource" style="color: rgba(255,255,255,0.7); font-size: 0.8em; white-space: nowrap;">Source:</label>
					<select id="pickerSearchSource" style="height: 32px; margin-right: 0.5em; font-size: 0.85em;">
						<option value="rdb">RDB Database</option>
						<option value="all">All Sources</option>
						<option value="gamesdb">TheGamesDB</option>
						<option value="gamefaqs">GameFAQs</option>
						<option value="coverproject">The Cover Project</option>
					</select>
					</div>
					<div style="display: flex; gap: 0.5em; align-items: center;">
						<input type="text" id="pickerSearchQuery" placeholder="Enter game name..." style="min-width: 200px; flex: 1;">
						<button class="btn-3d small" onclick="searchImagesInPicker()"><span class="icon solid fa-search"></span> Search</button>
					</div>
				</div>
				<button class="image-picker-close" onclick="closeImagePicker()">&times;</button>
			</div>
			<div class="image-picker-grid" id="pickerGrid">
				<div class="no-results">Enter a game name and click Search</div>
			</div>
			<div class="image-picker-footer">
				<button class="btn-3d green" id="pickerSelectBtn" onclick="confirmImageSelection()" disabled><span class="icon solid fa-check"></span> Select</button>
			</div>
		</div>

		<!-- Context Menu -->
		<div class="context-menu" id="contextMenu">
			<div class="context-menu-item" onclick="contextMenuAction('edit')">
				<span class="icon solid fa-edit"></span> Edit Box Art
			</div>
			<div class="context-menu-item" onclick="contextMenuAction('search')">
				<span class="icon solid fa-search"></span> Search Art
			</div>
			<div class="context-menu-item" onclick="contextMenuAction('google')">
				<span class="icon solid fa-external-link-alt"></span> Google Images
			</div>
			<div class="context-menu-divider"></div>
			<div class="context-menu-item" onclick="contextMenuAction('rename')">
				<span class="icon solid fa-i-cursor"></span> Rename
			</div>
			<div class="context-menu-item danger" onclick="contextMenuAction('delete')">
				<span class="icon solid fa-trash"></span> Delete Game
			</div>
		</div>

		<!-- Rename Modal -->
		<div class="modal-overlay" id="renameModal">
			<div class="modal-box" style="max-width: 450px;">
				<div class="modal-header">
					<h3><span class="icon solid fa-i-cursor"></span> Rename Game</h3>
					<button class="close-btn" onclick="closeModal('renameModal')">&times;</button>
				</div>
				<div class="compact-field" style="margin-bottom: 0.75em;">
					<label>New name (without extension):</label>
					<input type="text" id="renameInput" placeholder="Enter new name...">
				</div>
				<div style="margin-bottom: 1em;">
					<button class="btn-3d small cyan" onclick="autoCleanName()" style="width: 100%;"><span class="icon solid fa-magic"></span> Auto-Clean Name</button>
				</div>
				<p style="font-size: 0.8em; color: rgba(255,255,255,0.5); margin-bottom: 1em;">This will rename both the ROM file and its box art image.</p>
				<div style="display: flex; gap: 1em; justify-content: flex-end;">
					<button class="btn-3d small gray" onclick="closeModal('renameModal')"><span class="icon solid fa-times"></span> Cancel</button>
					<button class="btn-3d small green" onclick="executeRename()"><span class="icon solid fa-check"></span> Rename</button>
				</div>
				<div class="status-msg" id="renameStatus"></div>
			</div>
		</div>

		<!-- Device Selector Modal -->
		<div class="modal-overlay" id="deviceModal">
			<div class="modal-box" style="max-width: 650px;">
				<div class="modal-header">
					<h3 title="Choose your handheld device to ensure correct folder structure and box art sizing"><span class="icon solid fa-gamepad"></span> Select Your Device</h3>
					<button class="close-btn" onclick="closeModal('deviceModal')">&times;</button>
				</div>
				<div class="device-grid">
					<div class="device-card" onclick="selectDevice('rgnano')">
						<img src="assets/images/devices/rgnano.png" alt="RG Nano" class="device-image">
						<div class="device-name">Anbernic RG Nano</div>
						<div class="device-desc">Stock OS / Drum78 CFW</div>
					</div>
					<div class="device-card" onclick="selectDevice('onion')">
						<img src="assets/images/devices/miyoo-mini.png" alt="Miyoo Mini" class="device-image">
						<div class="device-name">Miyoo Mini / Plus</div>
						<div class="device-desc">Onion OS (250px)</div>
					</div>
					<div class="device-card" onclick="selectDevice('miyooflip')">
						<img src="assets/images/devices/miyoo-flip.png" alt="Miyoo Flip" class="device-image">
						<div class="device-name">Miyoo Flip / Mini Flip</div>
						<div class="device-desc">Onion OS (280px)</div>
					</div>
					<div class="device-card" onclick="selectDevice('trimuibrick')">
						<img src="assets/images/devices/trimuibrick.png" alt="Trimui Brick" class="device-image">
						<div class="device-name">Trimui Brick</div>
						<div class="device-desc">Mustard OS (354px)</div>
					</div>
					<div class="device-card" onclick="showMinUIResolutionModal()">
						<img src="assets/images/devices/minui.png" alt="MinUI" class="device-image">
						<div class="device-name">MinUI</div>
						<div class="device-desc">Multi-device OS</div>
					</div>
					<div class="device-card" onclick="showNextUIResolutionModal()">
						<img src="assets/images/devices/nextui.png" alt="NextUI" class="device-image">
						<div class="device-name">NextUI</div>
						<div class="device-desc">Multi-device OS</div>
					</div>
				</div>
				<div style="margin-top: 1.5em; text-align: center;">
					<button class="btn-3d" onclick="selectDevice('stock')" style="padding: 8px 16px; font-size: 0.9em; opacity: 0.7;">
						<span class="icon solid fa-folder"></span> Generic / Other Device
					</button>
				</div>
			</div>
		</div>

		<!-- MinUI Resolution Selector Modal -->
		<div class="modal-overlay" id="minuiResolutionModal">
			<div class="modal-box" style="max-width: 600px;">
				<div class="modal-header">
					<h3><span class="icon solid fa-display"></span> Select MinUI Resolution</h3>
					<button class="close-btn" onclick="closeModal('minuiResolutionModal')">&times;</button>
				</div>
				<p style="color: rgba(255,255,255,0.7); margin-bottom: 1.5em; text-align: center;">Choose the image resolution for your MinUI device.</p>
				<div class="device-grid" style="grid-template-columns: 1fr 1fr;">
					<div class="device-card" onclick="selectMinUIResolution('minui480')">
						<img src="assets/images/devices/trimsmart.png" alt="Trimui Smart" class="device-image">
						<div class="device-name">Standard</div>
						<div class="device-desc">200px images</div>
						<div style="margin-top: 0.5em; font-size: 0.85em; color: rgba(255,255,255,0.5);">RGB30, RG35XX, Trimui Smart</div>
					</div>
					<div class="device-card" onclick="selectMinUIResolution('minui1080')">
						<img src="assets/images/devices/rg405.png" alt="RG405" class="device-image">
						<div class="device-name">High-Res</div>
						<div class="device-desc">300px images</div>
						<div style="margin-top: 0.5em; font-size: 0.85em; color: rgba(255,255,255,0.5);">RG353 series, RG405 series</div>
					</div>
				</div>
			</div>
		</div>

		<!-- NextUI Resolution Selector Modal -->
		<div class="modal-overlay" id="nextuiResolutionModal">
			<div class="modal-box" style="max-width: 700px;">
				<div class="modal-header">
					<h3><span class="icon solid fa-display"></span> Select NextUI Resolution</h3>
					<button class="close-btn" onclick="closeModal('nextuiResolutionModal')">&times;</button>
				</div>
				<p style="color: rgba(255,255,255,0.7); margin-bottom: 1.5em; text-align: center;">Choose the image resolution for your NextUI device.</p>
				<div class="device-grid" style="grid-template-columns: 1fr 1fr 1fr;">
					<div class="device-card" onclick="selectNextUIResolution('nextui640')">
						<img src="assets/images/devices/rg35xxsp.png" alt="RG35XX SP" class="device-image">
						<div class="device-name">Standard</div>
						<div class="device-desc">200px images</div>
						<div style="margin-top: 0.5em; font-size: 0.85em; color: rgba(255,255,255,0.5);">RG35XX SP (640x480)</div>
					</div>
					<div class="device-card" onclick="selectNextUIResolution('nextui1024')">
						<img src="assets/images/devices/trimuibrick.png" alt="Trimui Brick" class="device-image">
						<div class="device-name">High-Res</div>
						<div class="device-desc">300px images</div>
						<div style="margin-top: 0.5em; font-size: 0.85em; color: rgba(255,255,255,0.5);">Trimui Brick (1024x768)</div>
					</div>
					<div class="device-card" onclick="selectNextUIResolution('nextui1280')">
						<img src="assets/images/devices/smartpro.png" alt="Trimui Smart Pro" class="device-image">
						<div class="device-name">Ultra</div>
						<div class="device-desc">400px images</div>
						<div style="margin-top: 0.5em; font-size: 0.85em; color: rgba(255,255,255,0.5);">Trimui Smart Pro (1280x720)</div>
					</div>
				</div>
			</div>
		</div>

		<!-- Folder Selection Instructions Modal -->
		<div class="modal-overlay" id="folderInstructionsModal">
			<div class="modal-box" style="max-width: 550px;">
				<div class="modal-header">
					<h3><span class="icon solid fa-folder-open"></span> Select Folder</h3>
				</div>
				<div style="padding: 2em; text-align: center;">
					<p id="folderInstructionText" style="font-size: 1.1em; line-height: 1.6; color: rgba(255,255,255,0.9); margin-bottom: 2em;"></p>
					<button class="btn-3d green" onclick="closeInstructionsAndScan()" style="width: 100%; padding: 16px 32px;">
						<span class="icon solid fa-check"></span> OK, Let's Go!
					</button>
				</div>
			</div>
		</div>

		<!-- Theme Selector Modal -->
		<div class="modal-overlay" id="themeModal">
			<div class="modal-box" style="max-width: 500px;">
				<div class="modal-header">
					<h3><span class="icon solid fa-palette"></span> Choose Theme</h3>
					<button class="close-btn" onclick="closeModal('themeModal')">&times;</button>
				</div>
				<p style="color: rgba(255,255,255,0.7); margin-bottom: 1.5em; text-align: center;">Select a color theme for your NanoArcade experience.</p>
				<div class="theme-grid">
					<div class="theme-card" onclick="setTheme('blue')" data-theme-card="blue">
						<div class="theme-preview blue"></div>
						<div class="theme-name">Blue</div>
					</div>
					<div class="theme-card" onclick="setTheme('purple')" data-theme-card="purple">
						<div class="theme-preview purple"></div>
						<div class="theme-name">Purple</div>
					</div>
					<div class="theme-card" onclick="setTheme('green')" data-theme-card="green">
						<div class="theme-preview green"></div>
						<div class="theme-name">Green</div>
					</div>
					<div class="theme-card" onclick="setTheme('red')" data-theme-card="red">
						<div class="theme-preview red"></div>
						<div class="theme-name">Red</div>
					</div>
					<div class="theme-card" onclick="setTheme('cyan')" data-theme-card="cyan">
						<div class="theme-preview cyan"></div>
						<div class="theme-name">Cyan</div>
					</div>
					<div class="theme-card" onclick="setTheme('orange')" data-theme-card="orange">
						<div class="theme-preview orange"></div>
						<div class="theme-name">Orange</div>
					</div>
					<div class="theme-card" onclick="setTheme('pink')" data-theme-card="pink">
						<div class="theme-preview pink"></div>
						<div class="theme-name">Pink</div>
					</div>
				</div>
			</div>
		</div>

		<!-- Error Modal -->
		<div class="modal-overlay" id="errorModal">
			<div class="modal-box" style="max-width: 500px;">
				<div class="modal-header">
					<h3><span class="icon solid fa-exclamation-triangle" style="color: #ef4444;"></span> Error</h3>
					<button class="close-btn" onclick="closeModal('errorModal')">&times;</button>
				</div>
				<div style="padding: 2em; text-align: center;">
					<p id="errorMessage" style="font-size: 1em; line-height: 1.6; color: rgba(255,255,255,0.9); margin-bottom: 2em;"></p>
					<button class="btn-3d red" onclick="closeModal('errorModal')" style="padding: 12px 24px;">
						<span class="icon solid fa-times"></span> Close
					</button>
				</div>
			</div>
		</div>

		<!-- Unsupported Browser Modal -->
		<div class="modal-overlay" id="unsupportedBrowserModal">
			<div class="modal-box" style="max-width: 550px;">
				<div class="modal-header">
					<h3><span class="icon solid fa-exclamation-triangle" style="color: #f59e0b;"></span> Browser Not Supported</h3>
					<button class="close-btn" onclick="closeModal('unsupportedBrowserModal')">&times;</button>
				</div>
				<div style="padding: 2em; text-align: center;">
					<p style="font-size: 1.1em; line-height: 1.6; color: rgba(255,255,255,0.9); margin-bottom: 1.5em;">
						This application requires the <strong>File System Access API</strong> which is not available in your current browser.
					</p>
					<p style="font-size: 0.95em; line-height: 1.5; color: rgba(255,255,255,0.7); margin-bottom: 2em;">
						Please use one of the following supported browsers:
					</p>
					<div class="browser-icons" style="display: flex; gap: 2em; justify-content: center; margin-bottom: 2em; flex-wrap: wrap;">
						<div class="browser-icon" style="display: flex; flex-direction: column; align-items: center; gap: 0.5em;">
							<img src="assets/images/browsers/chrome.png" alt="Chrome" width="48" height="48" style="filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));">
							<span style="color: rgba(255,255,255,0.8); font-size: 0.9em;">Chrome</span>
						</div>
						<div class="browser-icon" style="display: flex; flex-direction: column; align-items: center; gap: 0.5em;">
							<img src="assets/images/browsers/edge.png" alt="Edge" width="48" height="48" style="filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));">
							<span style="color: rgba(255,255,255,0.8); font-size: 0.9em;">Edge</span>
						</div>
						<div class="browser-icon" style="display: flex; flex-direction: column; align-items: center; gap: 0.5em;">
							<img src="assets/images/browsers/opera.png" alt="Opera" width="48" height="48" style="filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));">
							<span style="color: rgba(255,255,255,0.8); font-size: 0.9em;">Opera</span>
						</div>
					</div>
					<button class="btn-3d purple" onclick="closeModal('unsupportedBrowserModal')" style="padding: 12px 24px;">
						<span class="icon solid fa-check"></span> Got It
					</button>
				</div>
			</div>
		</div>

		<!-- Batch Libretro Progress Modal -->
		<div class="modal-overlay" id="batchLibretroModal">
			<div class="modal-box" style="max-width: 600px;">
				<div class="modal-header">
					<h3><span class="icon solid fa-download" style="color: #8b5cf6;"></span> Batch Libretro Processing</h3>
					<button class="close-btn" onclick="cancelBatchProcessing()">&times;</button>
				</div>
				<div style="margin-bottom: 1em;">
					<p style="margin-bottom: 1em;">Downloading box art for all games without images...</p>
					<div style="background: rgba(0,0,0,0.2); border-radius: 8px; overflow: hidden;">
						<div id="batchProgressBar" style="height: 8px; width: 0%; background: var(--theme-primary); transition: width 0.3s;"></div>
					</div>
				</div>
				<div style="margin-bottom: 1em; display: flex; justify-content: space-between;">
					<span>Progress: <span id="batchProgressText">0/0</span></span>
					<span>Success: <span id="batchSuccessCount" style="color: #4ade80;">0</span></span>
					<span>Failed: <span id="batchFailCount" style="color: #f87171;">0</span></span>
				</div>
				<div id="batchCurrentGame" style="margin-bottom: 1em; color: rgba(255,255,255,0.7);"></div>
				<div id="batchLog" style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 0.5em; border-radius: 8px; font-size: 0.8em;"></div>
				<div style="display: flex; justify-content: flex-end; gap: 0.5em; margin-top: 1em;">
					<button class="btn-3d small red" id="batchCancelBtn" onclick="cancelBatchProcessing()">
						<span class="icon solid fa-times"></span> Cancel
					</button>
					<button class="btn-3d small gray" id="batchCloseBtn" onclick="closeBatchModal()" style="display: none;">
						<span class="icon solid fa-check"></span> Close
					</button>
				</div>
			</div>
		</div>

		<!-- Save Manager Modal -->
		<div class="modal-overlay" id="saveModal">
			<div class="modal-box" style="max-width: 600px;">
				<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1em;">
					<h3 style="color: #22d3ee; font-size: 1.1em; margin: 0; text-shadow: 0 0 20px rgba(34, 211, 238, 0.5);">
						<span class="icon solid fa-save" style="margin-right: 0.5em;"></span>Save Manager - <span id="saveGameName">Game</span>
					</h3>
					<button class="close-btn" onclick="closeModal('saveModal')">&times;</button>
				</div>

				<!-- Local Saves -->
				<div id="localSavesList" style="max-height: 300px; overflow-y: auto;">
					<div class="loading-container" style="padding: 2em;">
						<div class="spinner"></div>
						<div class="loading-text">Checking for saves...</div>
					</div>
				</div>
				<div style="margin-top: 1em; padding-top: 1em; border-top: 1px solid rgba(34, 211, 238, 0.2);">
					<button class="btn-3d small green" onclick="uploadLocalSave()" style="width: 100%;">
						<span class="icon solid fa-upload"></span> Restore Save File
					</button>
					<input type="file" id="saveFileInput" accept=".sav,.srm" style="display:none;" onchange="handleSaveUpload(event)">
				</div>
			</div>
		</div>

		<!-- Footer -->
		<footer id="footer" class="wrapper style1-alt">
			<div class="inner">
				<span class="version-number">v1.5</span>
			</div>
		</footer>

		<!-- Scripts -->
		<script src="assets/js/jquery.min.js"></script>
		<script src="assets/js/jquery.scrollex.min.js"></script>
		<script src="assets/js/jquery.scrolly.min.js"></script>
		<script src="assets/js/browser.min.js"></script>
		<script src="assets/js/breakpoints.min.js"></script>
		<script src="assets/js/util.js"></script>
		<script src="assets/js/main.js"></script>

		<script>
			// Global state
			let directoryHandle = null;
			let consoles = {};
			let currentConsole = null;
			let currentGame = null;
			let filesToUpload = [];
			let filterMissingOnly = false;
			let currentSort = 'az';
			let contextMenuTarget = null;
			let contextMenuConsole = null;
			let currentDevice = 'rgnano';
			let objectURLs = []; // Track object URLs for cleanup
			let currentTheme = 'blue';

			// Theme functions
			function initTheme() {
				const savedTheme = localStorage.getItem('nanoarcade-theme') || 'blue';
				setTheme(savedTheme, false);
			}

			function showThemeSelector() {
				// Update active state on cards
				document.querySelectorAll('.theme-card').forEach(card => {
					card.classList.remove('active');
					if (card.dataset.themeCard === currentTheme) {
						card.classList.add('active');
					}
				});
				document.getElementById('themeModal').classList.add('active');
			}

			function setTheme(themeName, save = true) {
				currentTheme = themeName;
				document.documentElement.setAttribute('data-theme', themeName);

				// Update active state on cards if modal is open
				document.querySelectorAll('.theme-card').forEach(card => {
					card.classList.remove('active');
					if (card.dataset.themeCard === themeName) {
						card.classList.add('active');
					}
				});

				// Save to localStorage
				if (save) {
					localStorage.setItem('nanoarcade-theme', themeName);
					closeModal('themeModal');
				}
			}

			// Initialize theme on page load
			document.addEventListener('DOMContentLoaded', initTheme);

			// Helper to create data URL from blob (works on file:// protocol)
			function blobToDataURL(blob) {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onload = () => resolve(reader.result);
					reader.onerror = reject;
					reader.readAsDataURL(blob);
				});
			}

			// Helper to create URL from blob - uses data URL for file:// protocol compatibility
			async function createObjectURL(blob) {
				// Use data URLs to avoid blob:null issues on file:// protocol
				return await blobToDataURL(blob);
			}

			// Revoke all tracked object URLs (no-op for data URLs, kept for compatibility)
			function revokeObjectURLs() {
				objectURLs = [];
			}
			let pendingDirectoryHandle = null;

			// Onion OS folder structure (shared by all Miyoo devices)
			const onionFolderMap = {
				'GB': ['GB'],
				'GBC': ['GBC'],
				'GBA': ['GBA'],
				'NES': ['FC'],  // Famicom
				'FDS': ['FDS'], // Famicom Disk System
				'SNES': ['SFC'], // Super Famicom
				'Genesis': ['MD'], // Mega Drive
				'Game Gear': ['GG'],
				'PS1': ['PS'],
				'PCE': ['PCE'], // PC Engine
				'PCE CD': ['PCECD'],
				'Arcade': ['ARCADE', 'FBN', 'MAME'],
				'CPS3': ['CPS3'],
				'Master System': ['MS'],
				'Neo Geo': ['NEOGEO'],
				'Atari 2600': ['ATARI'],
				'Atari Lynx': ['LYNX'],
				'Atari 5200': ['FIFTYTWOHUNDRED'],
				'Atari 7800': ['SEVENTYEIGHTHUNDRED'],
				'Virtual Boy': ['VB'],
				'WonderSwan': ['WS'],
				'Neo Geo Pocket': ['NGP'],
				'N64': ['N64'],
				'NDS': ['NDS'],
				'PSP': ['PSP'],
				'DOS': ['DOS'],
				'ColecoVision': ['COLECO'],
				'Commodore': ['COMMODORE'],
				'Game & Watch': ['GW'],
				'Sega CD': ['SEGACD'],
				'PICO-8': ['PICO'],
				'ScummVM': ['SCUMMVM'],
				'Vectrex': ['VECTREX'],
				'ZX Spectrum': ['ZXS'],
				'Satellaview': ['SATELLAVIEW']
			};

			// Device profiles with folder mappings and settings
			const deviceProfiles = {
				rgnano: {
					name: 'Anbernic RG Nano',
					emoji: 'ðŸŽ®',
					imageSize: 240,
					// Maps display name to folder name(s)
					folderMap: {
						'GB': ['Game Boy', 'GB'],
						'GBC': ['Game Boy Color', 'GBC'],
						'GBA': ['Game Boy Advance', 'GBA'],
						'NES': ['NES', 'FC'],
						'SNES': ['SNES', 'SFC'],
						'Genesis': ['Sega Genesis', 'Genesis', 'MD'],
						'Game Gear': ['Game Gear', 'GG'],
						'Master System': ['Sega Master System', 'Master System', 'MS'],
						'PS1': ['PS1', 'PS', 'PSX'],
						'PCE': ['PCE-TurboGrafx', 'PCE'],
						'Arcade': ['Final Burn Alpha 2012', 'MAME 2000', 'ARCADE', 'FBA', 'MAME'],
						'Atari Lynx': ['Atari lynx', 'Atari Lynx'],
						'Neo Geo Pocket': ['Neo Geo Pocket', 'NGP'],
						'WonderSwan': ['WonderSwan', 'WS'],
						'Pokemon Mini': ['Pokemon Mini']
					}
				},
				onion: {
					name: 'Miyoo Mini / Plus',
					emoji: 'ðŸ§…',
					imageSize: 250,
					romsFolder: 'Roms',
					folderMap: onionFolderMap
				},
				miyooflip: {
					name: 'Miyoo Flip / Mini Flip',
					emoji: 'ðŸ§…',
					imageSize: 280,
					romsFolder: 'Roms',
					folderMap: onionFolderMap
				},
				stock: {
					name: 'Generic',
					emoji: 'ðŸ“',
					imageSize: 240,
					folderMap: {
						// Supports RetroPie, EmulationStation, Batocera, and common naming conventions
						'GB': ['gb', 'GB', 'gameboy', 'Gameboy', 'GameBoy'],
						'GBC': ['gbc', 'GBC', 'gameboycolor', 'GameBoyColor'],
						'GBA': ['gba', 'GBA', 'gameboyadvance', 'GameBoyAdvance'],
						'NES': ['nes', 'NES', 'famicom', 'Famicom', 'FC', 'fc'],
						'SNES': ['snes', 'SNES', 'sfc', 'SFC', 'supernes', 'SuperNES', 'superfamicom', 'SuperFamicom'],
						'Genesis': ['megadrive', 'Megadrive', 'MegaDrive', 'genesis', 'Genesis', 'MD', 'md'],
						'Game Gear': ['gamegear', 'GameGear', 'GG', 'gg'],
						'Master System': ['mastersystem', 'MasterSystem', 'sms', 'SMS', 'MS', 'ms'],
						'PS1': ['psx', 'PSX', 'ps1', 'PS1', 'playstation', 'PlayStation', 'PS', 'ps'],
						'N64': ['n64', 'N64', 'nintendo64', 'Nintendo64'],
						'PCE': ['pcengine', 'PCEngine', 'pce', 'PCE', 'turbografx', 'TurboGrafx', 'tg16', 'TG16'],
						'Arcade': ['arcade', 'Arcade', 'ARCADE', 'mame', 'MAME', 'fba', 'FBA', 'fbneo', 'FBNeo', 'neogeo', 'NeoGeo', 'NEOGEO'],
						'Neo Geo': ['neogeo', 'NeoGeo', 'NEOGEO', 'ng'],
						'Atari 2600': ['atari2600', 'Atari2600', 'atari', 'Atari', 'ATARI'],
						'Atari 7800': ['atari7800', 'Atari7800'],
						'Atari 5200': ['atari5200', 'Atari5200'],
						'Atari Lynx': ['atarilynx', 'AtariLynx', 'lynx', 'Lynx'],
						'Virtual Boy': ['virtualboy', 'VirtualBoy', 'vb', 'VB'],
						'WonderSwan': ['wonderswan', 'WonderSwan', 'ws', 'WS'],
						'Neo Geo Pocket': ['ngp', 'NGP', 'ngpc', 'NGPC', 'neogeopocket', 'NeoGeoPocket'],
						'NDS': ['nds', 'NDS', 'ds', 'DS', 'nintendods', 'NintendoDS'],
						'PSP': ['psp', 'PSP'],
						'Sega CD': ['segacd', 'SegaCD', 'megacd', 'MegaCD'],
						'Sega 32X': ['sega32x', 'Sega32X', '32x', '32X'],
						'Dreamcast': ['dreamcast', 'Dreamcast', 'dc', 'DC'],
						'Saturn': ['saturn', 'Saturn', 'segasaturn', 'SegaSaturn'],
						'Coleco': ['coleco', 'Coleco', 'colecovision', 'ColecoVision'],
						'Intellivision': ['intellivision', 'Intellivision'],
						'Vectrex': ['vectrex', 'Vectrex'],
						'MSX': ['msx', 'MSX', 'msx2', 'MSX2'],
						'Commodore 64': ['c64', 'C64', 'commodore64', 'Commodore64'],
						'Amiga': ['amiga', 'Amiga'],
						'DOS': ['dos', 'DOS', 'dosbox', 'DOSBox'],
						'ScummVM': ['scummvm', 'ScummVM', 'SCUMMVM']
					}
				},
				trimuibrick: {
					name: 'Trimui Brick',
					emoji: 'ðŸ§±',
					imageSize: 354,
					catalogueStructure: true,  // Flag for 3-tier folder handling (MUOS/info/catalogue/<System>/box/)
					folderMap: {
						// Handheld
						'GB': ['gameboy', 'gb'],
						'GBC': ['gbc'],
						'GBA': ['gba'],
						'Game Gear': ['gamegear'],
						'Atari Lynx': ['lynx'],
						'WonderSwan': ['wonderswan'],
						'Neo Geo Pocket': ['neogeopocket'],
						'NDS': ['nds'],
						'PSP': ['psp'],
						'Pokemon Mini': ['pokemini'],
						'Mega Duck': ['megaduck'],
						'Watara Supervision': ['supervision'],
						'Arduboy': ['arduboy'],
						'Game and Watch': ['gameandwatch'],
						'VeMUlator': ['vemulator'],
						'TI-83': ['ti83'],
						'Java J2ME': ['java'],
						// Home Console
						'NES': ['nes'],
						'FDS': ['fds'],
						'SNES': ['snes'],
						'N64': ['n64'],
						'Virtual Boy': ['virtualboy'],
						'Genesis': ['segamd'],
						'Master System': ['mastersystem'],
						'Sega CD': ['segamdcd'],
						'Sega 32X': ['sega32x'],
						'Saturn': ['saturn'],
						'Dreamcast': ['dreamcast'],
						'SG-1000': ['sg1000'],
						'Sega Pico': ['segapico'],
						'PS1': ['ps1'],
						'PCE': ['pcengine'],
						'PCE CD': ['pcenginecd'],
						'SuperGrafx': ['supergrafx'],
						'PC-FX': ['pcfx'],
						'Neo Geo': ['neogeo'],
						'Neo Geo CD': ['neogeocd'],
						'Atari 2600': ['atari2600'],
						'Atari 5200': ['atari5200'],
						'Atari 7800': ['atari7800'],
						'Atari Jaguar': ['jaguar'],
						'Coleco': ['colecovision'],
						'Intellivision': ['intellivision'],
						'Vectrex': ['vectrex'],
						'3DO': ['3do'],
						'CDi': ['cdi'],
						'Channel F': ['channelf'],
						'Odyssey': ['odyssey'],
						// Computer
						'MSX': ['msx'],
						'Commodore 64': ['c64'],
						'Commodore VIC-20': ['vic20'],
						'Commodore C128': ['c128'],
						'Commodore PET': ['pet'],
						'Commodore CBM-II': ['cbm'],
						'Amiga': ['amiga'],
						'DOS': ['dos'],
						'Amstrad': ['amstrad'],
						'Atari ST': ['atarist'],
						'ZX Spectrum': ['zxspectrum'],
						'ZX 81': ['zx81'],
						'PC-8000/8800': ['pc8000'],
						'PC98': ['pc98'],
						'Sharp X1': ['x1'],
						'Sharp X68000': ['x68000'],
						'Galaksija': ['galaksija'],
						'Spectravision SVI': ['svi'],
						// Arcade
						'Arcade': ['arcade'],
						'Atomiswave/Naomi': ['naomi'],
						// Fantasy Console
						'PICO-8': ['pico8'],
						'TIC-80': ['tic80'],
						'LowRes NX': ['lowresnx'],
						'Vircon32': ['vircon32'],
						'WASM-4': ['wasm4'],
						// Misc
						'ScummVM': ['scummvm'],
						'OpenBOR': ['openbor'],
						'EasyRPG': ['easyrpg'],
						'Cave Story': ['cavestory'],
						'Doom': ['doom'],
						'Quake': ['quake'],
						'Wolfenstein 3D': ['wolfenstein'],
						'CHIP-8': ['chip8'],
						'Uzebox': ['uzebox']
					}
				},
				minui480: {
					name: 'MinUI (Standard)',
					emoji: 'ðŸŽ®',
					imageSize: 200,
					isMinUI: true,
					resolution: 'standard',
					folderMap: {
						'GB': ['Game Boy (GB)'],
						'GBC': ['Game Boy Color (GBC)'],
						'GBA': ['Game Boy Advance (GBA)'],
						'NES': ['NES (NES)', 'Nintendo (NES)', 'Nintendo Entertainment System (FC)'],
						'FDS': ['Famicom Disk System (FDS)'],
						'SNES': ['Super Nintendo (SFC)', 'SNES (SFC)'],
						'N64': ['Nintendo 64 (N64)'],
						'Genesis': ['Sega Genesis (MD)', 'Genesis (MD)'],
						'Master System': ['Sega Master System (SMS)', 'Master System (SMS)'],
						'Game Gear': ['Game Gear (GG)'],
						'PS1': ['PlayStation (PS)', 'PS1 (PS)'],
						'PCE': ['PC Engine (PCE)', 'TurboGrafx-16 (PCE)', 'NEC PC Engine (PCE)'],
						'Neo Geo': ['Neo Geo (NEOGEO)'],
						'Neo Geo Pocket': ['Neo Geo Pocket (NGP)', 'Neo Geo Pocket Color (NGP)', 'SNK Neo Geo Pocket (NGP)'],
						'Virtual Boy': ['Virtual Boy (VB)'],
						'Pokemon Mini': ['Pokemon Mini (POKE)'],
						'Pico-8': ['Pico-8 (PICO)'],
						'WonderSwan': ['Bandai WonderSwan (WS)', 'WonderSwan (WS)', 'WonderSwan Color (WS)']
					}
				},
				minui1080: {
					name: 'MinUI (High-Res)',
					emoji: 'ðŸŽ®',
					imageSize: 300,
					isMinUI: true,
					resolution: 'high-res',
					folderMap: {
						'GB': ['Game Boy (GB)'],
						'GBC': ['Game Boy Color (GBC)'],
						'GBA': ['Game Boy Advance (GBA)'],
						'NES': ['NES (NES)', 'Nintendo (NES)', 'Nintendo Entertainment System (FC)'],
						'FDS': ['Famicom Disk System (FDS)'],
						'SNES': ['Super Nintendo (SFC)', 'SNES (SFC)'],
						'N64': ['Nintendo 64 (N64)'],
						'Genesis': ['Sega Genesis (MD)', 'Genesis (MD)'],
						'Master System': ['Sega Master System (SMS)', 'Master System (SMS)'],
						'Game Gear': ['Game Gear (GG)'],
						'PS1': ['PlayStation (PS)', 'PS1 (PS)'],
						'PCE': ['PC Engine (PCE)', 'TurboGrafx-16 (PCE)', 'NEC PC Engine (PCE)'],
						'Neo Geo': ['Neo Geo (NEOGEO)'],
						'Neo Geo Pocket': ['Neo Geo Pocket (NGP)', 'Neo Geo Pocket Color (NGP)', 'SNK Neo Geo Pocket (NGP)'],
						'Virtual Boy': ['Virtual Boy (VB)'],
						'Pokemon Mini': ['Pokemon Mini (POKE)'],
						'Pico-8': ['Pico-8 (PICO)'],
						'WonderSwan': ['Bandai WonderSwan (WS)', 'WonderSwan (WS)', 'WonderSwan Color (WS)']
					}
				},
				nextui640: {
					name: 'NextUI (Standard)',
					emoji: 'âš¡',
					imageSize: 200,
					isNextUI: true,
					resolution: 'standard',
					folderMap: {
						'GB': ['Game Boy (GB)'],
						'GBC': ['Game Boy Color (GBC)'],
						'GBA': ['Game Boy Advance (GBA)'],
						'NES': ['NES (NES)', 'Nintendo (NES)', 'Nintendo Entertainment System (FC)'],
						'FDS': ['Famicom Disk System (FDS)'],
						'SNES': ['Super Nintendo (SFC)', 'SNES (SFC)'],
						'N64': ['Nintendo 64 (N64)'],
						'Genesis': ['Sega Genesis (MD)', 'Genesis (MD)'],
						'Master System': ['Sega Master System (SMS)', 'Master System (SMS)'],
						'Game Gear': ['Game Gear (GG)'],
						'PS1': ['PlayStation (PS)', 'PS1 (PS)'],
						'PCE': ['PC Engine (PCE)', 'TurboGrafx-16 (PCE)', 'NEC PC Engine (PCE)'],
						'Neo Geo': ['Neo Geo (NEOGEO)'],
						'Neo Geo Pocket': ['Neo Geo Pocket (NGP)', 'Neo Geo Pocket Color (NGP)', 'SNK Neo Geo Pocket (NGP)'],
						'Virtual Boy': ['Virtual Boy (VB)'],
						'Pokemon Mini': ['Pokemon Mini (POKE)'],
						'Pico-8': ['Pico-8 (PICO)'],
						'WonderSwan': ['Bandai WonderSwan (WS)', 'WonderSwan (WS)', 'WonderSwan Color (WS)']
					}
				},
			nextui1024: {
				name: 'NextUI (High-Res)',
				emoji: 'âš¡',
				imageSize: 300,
				isNextUI: true,
				resolution: 'high-res',
				folderMap: {
					'GB': ['Game Boy (GB)'],
					'GBC': ['Game Boy Color (GBC)'],
					'GBA': ['Game Boy Advance (GBA)'],
					'NES': ['NES (NES)', 'Nintendo (NES)', 'Nintendo Entertainment System (FC)'],
					'FDS': ['Famicom Disk System (FDS)'],
					'SNES': ['Super Nintendo (SFC)', 'SNES (SFC)'],
					'N64': ['Nintendo 64 (N64)'],
					'Genesis': ['Sega Genesis (MD)', 'Genesis (MD)'],
					'Master System': ['Sega Master System (SMS)', 'Master System (SMS)'],
					'Game Gear': ['Game Gear (GG)'],
					'PS1': ['PlayStation (PS)', 'PS1 (PS)'],
					'PCE': ['PC Engine (PCE)', 'TurboGrafx-16 (PCE)', 'NEC PC Engine (PCE)'],
					'Neo Geo': ['Neo Geo (NEOGEO)'],
					'Neo Geo Pocket': ['Neo Geo Pocket (NGP)', 'Neo Geo Pocket Color (NGP)', 'SNK Neo Geo Pocket (NGP)'],
					'Virtual Boy': ['Virtual Boy (VB)'],
					'Pokemon Mini': ['Pokemon Mini (POKE)'],
					'Pico-8': ['Pico-8 (PICO)'],
					'WonderSwan': ['Bandai WonderSwan (WS)', 'WonderSwan (WS)', 'WonderSwan Color (WS)']
				}
			},
			nextui1280: {
				name: 'NextUI (Ultra)',
				emoji: 'âš¡',
				imageSize: 400,
				isNextUI: true,
				resolution: 'ultra',
				folderMap: {
					'GB': ['Game Boy (GB)'],
					'GBC': ['Game Boy Color (GBC)'],
					'GBA': ['Game Boy Advance (GBA)'],
					'NES': ['NES (NES)', 'Nintendo (NES)', 'Nintendo Entertainment System (FC)'],
					'FDS': ['Famicom Disk System (FDS)'],
					'SNES': ['Super Nintendo (SFC)', 'SNES (SFC)'],
					'N64': ['Nintendo 64 (N64)'],
					'Genesis': ['Sega Genesis (MD)', 'Genesis (MD)'],
					'Master System': ['Sega Master System (SMS)', 'Master System (SMS)'],
					'Game Gear': ['Game Gear (GG)'],
					'PS1': ['PlayStation (PS)', 'PS1 (PS)'],
					'PCE': ['PC Engine (PCE)', 'TurboGrafx-16 (PCE)', 'NEC PC Engine (PCE)'],
					'Neo Geo': ['Neo Geo (NEOGEO)'],
					'Neo Geo Pocket': ['Neo Geo Pocket (NGP)', 'Neo Geo Pocket Color (NGP)', 'SNK Neo Geo Pocket (NGP)'],
					'Virtual Boy': ['Virtual Boy (VB)'],
					'Pokemon Mini': ['Pokemon Mini (POKE)'],
					'Pico-8': ['Pico-8 (PICO)'],
					'WonderSwan': ['Bandai WonderSwan (WS)', 'WonderSwan (WS)', 'WonderSwan Color (WS)']
				}
			}
		};

		// Top 25 rated games per console (for "must have" list feature)
			const topGamesData = {
				'GBA': [
					'Legend of Zelda, The - The Minish Cap',
					'Metroid - Zero Mission',
					'Metroid Fusion',
					'Pokemon Emerald',
					'Pokemon FireRed',
					'Pokemon LeafGreen',
					'Castlevania - Aria of Sorrow',
					'Castlevania - Harmony of Dissonance',
					'Advance Wars',
					'Advance Wars 2 - Black Hole Rising',
					'Golden Sun',
					'Golden Sun - The Lost Age',
					'Fire Emblem',
					'Fire Emblem - The Sacred Stones',
					'Mario & Luigi - Superstar Saga',
					'Final Fantasy VI Advance',
					'Final Fantasy Tactics Advance',
					'Legend of Zelda, The - A Link to the Past',
					'Super Mario Advance 4 - Super Mario Bros. 3',
					'Wario Land 4',
					'WarioWare, Inc. - Mega Microgames!',
					'Kirby & The Amazing Mirror',
					'Mega Man Zero',
					'Sonic Advance',
					'Mario Kart - Super Circuit'
				],
				'GB': [
					'Legend of Zelda, The - Link\'s Awakening',
					'Tetris',
					'Pokemon Red',
					'Pokemon Blue',
					'Pokemon Yellow',
					'Super Mario Land 2 - 6 Golden Coins',
					'Super Mario Land',
					'Donkey Kong',
					'Metroid II - Return of Samus',
					'Kirby\'s Dream Land',
					'Kirby\'s Dream Land 2',
					'Wario Land - Super Mario Land 3',
					'Final Fantasy Adventure',
					'Mega Man - Dr. Wily\'s Revenge',
					'Mega Man II',
					'Mega Man III',
					'Mega Man IV',
					'Mega Man V',
					'Gargoyle\'s Quest',
					'Kid Icarus - Of Myths and Monsters',
					'Castlevania - The Adventure',
					'Castlevania II - Belmont\'s Revenge',
					'Batman',
					'Contra - The Alien Wars',
					'Dr. Mario'
				],
				'GBC': [
					'Legend of Zelda, The - Oracle of Ages',
					'Legend of Zelda, The - Oracle of Seasons',
					'Legend of Zelda, The - Link\'s Awakening DX',
					'Pokemon Gold',
					'Pokemon Silver',
					'Pokemon Crystal',
					'Metal Gear Solid',
					'Wario Land 3',
					'Wario Land II',
					'Dragon Warrior III',
					'Super Mario Bros. Deluxe',
					'Mario Tennis',
					'Mario Golf',
					'Pokemon Trading Card Game',
					'Pokemon Pinball',
					'Donkey Kong Country',
					'Shantae',
					'Mega Man Xtreme',
					'Mega Man Xtreme 2',
					'R-Type DX',
					'Bionic Commando - Elite Forces',
					'Dragon Warrior Monsters',
					'Dragon Warrior Monsters 2',
					'Harvest Moon GBC',
					'Kirby Tilt \'n\' Tumble'
				],
				'NES': [
					'Super Mario Bros. 3',
					'Legend of Zelda, The',
					'Super Mario Bros.',
					'Super Mario Bros. 2',
					'Zelda II - The Adventure of Link',
					'Mega Man 2',
					'Mega Man 3',
					'Metroid',
					'Contra',
					'Castlevania',
					'Castlevania III - Dracula\'s Curse',
					'Punch-Out!!',
					'Final Fantasy',
					'Dragon Warrior',
					'Dragon Warrior III',
					'Dragon Warrior IV',
					'Kirby\'s Adventure',
					'Ninja Gaiden',
					'Ninja Gaiden II',
					'Ninja Gaiden III',
					'Tecmo Super Bowl',
					'DuckTales',
					'Mega Man',
					'Bionic Commando',
					'Battletoads'
				],
				'SNES': [
					'Chrono Trigger',
					'Legend of Zelda, The - A Link to the Past',
					'Super Mario World',
					'Super Metroid',
					'Final Fantasy VI',
					'Final Fantasy IV',
					'EarthBound',
					'Super Mario World 2 - Yoshi\'s Island',
					'Secret of Mana',
					'Super Mario RPG',
					'Donkey Kong Country',
					'Donkey Kong Country 2 - Diddy\'s Kong Quest',
					'Donkey Kong Country 3',
					'Mega Man X',
					'Mega Man X2',
					'Mega Man X3',
					'Street Fighter II Turbo',
					'Super Mario Kart',
					'F-Zero',
					'Star Fox',
					'Contra III - The Alien Wars',
					'Castlevania IV',
					'Teenage Mutant Ninja Turtles IV - Turtles in Time',
					'ActRaiser',
					'Kirby Super Star'
				],
				'Genesis': [
					'Sonic the Hedgehog 2',
					'Sonic the Hedgehog',
					'Sonic the Hedgehog 3',
					'Sonic & Knuckles',
					'Streets of Rage 2',
					'Streets of Rage',
					'Gunstar Heroes',
					'Phantasy Star IV',
					'Shining Force',
					'Shining Force II',
					'Castlevania - Bloodlines',
					'Contra - Hard Corps',
					'Earthworm Jim',
					'Earthworm Jim 2',
					'Shinobi III',
					'Revenge of Shinobi',
					'Golden Axe',
					'Comix Zone',
					'Vectorman',
					'Vectorman 2',
					'Thunder Force III',
					'Thunder Force IV',
					'Rocket Knight Adventures',
					'Altered Beast',
					'Toejam & Earl'
				],
				'Game Gear': [
					'Sonic Triple Trouble',
					'Sonic the Hedgehog',
					'Sonic the Hedgehog 2',
					'Shinobi',
					'Shinobi II - The Silent Fury',
					'Shining Force - Sword of Hajya',
					'Defenders of Oasis',
					'Gunstar Heroes',
					'Streets of Rage 2',
					'Castle of Illusion',
					'Land of Illusion',
					'Tails Adventure',
					'Columns',
					'Sonic Chaos',
					'GG Aleste',
					'Ax Battler',
					'Dragon Crystal',
					'Phantasy Star Adventure',
					'Wonder Boy - The Dragon\'s Trap',
					'Power Strike II',
					'Vampire - Master of Darkness',
					'Ninja Gaiden',
					'Ristar',
					'Mortal Kombat',
					'NBA Jam'
				],
				'Master System': [
					'Sonic the Hedgehog',
					'Phantasy Star',
					'Wonder Boy III - The Dragon\'s Trap',
					'Wonder Boy in Monster Land',
					'Alex Kidd in Miracle World',
					'Alex Kidd in Shinobi World',
					'Shinobi',
					'Golden Axe Warrior',
					'Ninja Gaiden',
					'Castle of Illusion',
					'Land of Illusion',
					'R-Type',
					'Power Strike',
					'Power Strike II',
					'Golvellius',
					'Zillion',
					'Spellcaster',
					'Master of Darkness',
					'Psycho Fox',
					'Asterix',
					'Lucky Dime Caper',
					'Sonic the Hedgehog 2',
					'Streets of Rage',
					'Sonic Chaos',
					'Columns'
				],
				'PS1': [
					'Final Fantasy VII',
					'Metal Gear Solid',
					'Castlevania - Symphony of the Night',
					'Resident Evil 2',
					'Final Fantasy IX',
					'Chrono Cross',
					'Final Fantasy Tactics',
					'Silent Hill',
					'Tekken 3',
					'Resident Evil',
					'Gran Turismo 2',
					'Crash Bandicoot - Warped',
					'Crash Bandicoot 2 - Cortex Strikes Back',
					'Spyro the Dragon',
					'Spyro 2 - Ripto\'s Rage',
					'Tony Hawk\'s Pro Skater 2',
					'Twisted Metal 2',
					'Vagrant Story',
					'Parasite Eve',
					'Legend of Dragoon',
					'Suikoden II',
					'Xenogears',
					'Ape Escape',
					'MediEvil',
					'PaRappa the Rapper'
				],
				'N64': [
					'Legend of Zelda, The - Ocarina of Time',
					'Super Mario 64',
					'GoldenEye 007',
					'Legend of Zelda, The - Majora\'s Mask',
					'Banjo-Kazooie',
					'Perfect Dark',
					'Super Smash Bros.',
					'Mario Kart 64',
					'Banjo-Tooie',
					'Paper Mario',
					'Star Fox 64',
					'F-Zero X',
					'Conker\'s Bad Fur Day',
					'Diddy Kong Racing',
					'Pokemon Stadium',
					'Pokemon Stadium 2',
					'Wave Race 64',
					'1080 Snowboarding',
					'Mario Party 2',
					'Mario Party 3',
					'Kirby 64 - The Crystal Shards',
					'Ogre Battle 64',
					'Sin and Punishment',
					'Star Wars - Rogue Squadron',
					'Blast Corps'
				],
				'PCE': [
					'Castlevania - Rondo of Blood',
					'Ys Book I & II',
					'Bonk\'s Adventure',
					'Bonk\'s Revenge',
					'Blazing Lazers',
					'R-Type',
					'Gate of Thunder',
					'Lords of Thunder',
					'Soldier Blade',
					'Super Star Soldier',
					'Ninja Spirit',
					'Splatterhouse',
					'Military Madness',
					'Dungeon Explorer',
					'Devil\'s Crush',
					'Alien Crush',
					'Air Zonk',
					'Bomberman \'94',
					'Bomberman \'93',
					'Neutopia',
					'Neutopia II',
					'Legendary Axe',
					'Legendary Axe II',
					'Cadash',
					'Snatcher'
				],
				'Neo Geo': [
					'Garou - Mark of the Wolves',
					'Metal Slug 3',
					'Metal Slug X',
					'Metal Slug',
					'King of Fighters \'98',
					'King of Fighters \'97',
					'Samurai Shodown II',
					'Last Blade 2',
					'Last Blade',
					'Real Bout Fatal Fury 2',
					'Fatal Fury Special',
					'Art of Fighting 3',
					'Shock Troopers',
					'Shock Troopers - 2nd Squad',
					'Blazing Star',
					'Pulstar',
					'Neo Turf Masters',
					'Windjammers',
					'Twinkle Star Sprites',
					'Baseball Stars 2',
					'Top Hunter',
					'Magician Lord',
					'Sengoku 3',
					'Matrimelee',
					'Kizuna Encounter'
				],
				'Atari Lynx': [
					'California Games',
					'Chip\'s Challenge',
					'Todd\'s Adventures in Slime World',
					'Blue Lightning',
					'Robotron 2084',
					'Xenophobe',
					'RoadBlasters',
					'Rampage',
					'Klax',
					'Lemmings',
					'Checkered Flag',
					'BattleWheels',
					'Double Dragon',
					'Ninja Gaiden',
					'Shadow of the Beast',
					'Rygar',
					'Toki',
					'Viking Child',
					'Gates of Zendocon',
					'Warbirds',
					'Xybots',
					'Gauntlet - The Third Encounter',
					'Basketbrawl',
					'Electrocop',
					'Zarlor Mercenary'
				],
				'Atari 2600': [
					'Pitfall!',
					'Pitfall II - Lost Caverns',
					'Adventure',
					'Yars\' Revenge',
					'River Raid',
					'Missile Command',
					'Space Invaders',
					'Asteroids',
					'Pac-Man',
					'Ms. Pac-Man',
					'Demon Attack',
					'Frogger',
					'Centipede',
					'Defender',
					'Berzerk',
					'Combat',
					'Kaboom!',
					'Q*bert',
					'Donkey Kong',
					'Joust',
					'Jungle Hunt',
					'Dig Dug',
					'Pole Position',
					'Enduro',
					'H.E.R.O.'
				],
				'WonderSwan': [
					'Final Fantasy',
					'Final Fantasy II',
					'Judgement Silversword',
					'Gunpey',
					'Makaimura',
					'Klonoa - Moonlight Museum',
					'Mr. Driller',
					'Tetris',
					'Guilty Gear Petit 2',
					'One Piece Grand Battle',
					'Front Mission',
					'Rhyme Rider Kerorican',
					'Rainbow Islands',
					'Golden Axe',
					'Rockman & Forte',
					'Dicing Knight Period',
					'Digimon Adventure',
					'Chocobo no Fushigi na Dungeon',
					'Beatmania',
					'Densha de Go! 2',
					'Buffers Evolution',
					'Crazy Climber',
					'Makai Toushi SaGa',
					'Romancing SaGa',
					'SD Gundam G Generation'
				],
				'Neo Geo Pocket': [
					'SNK vs. Capcom - Match of the Millennium',
					'SNK vs. Capcom - Card Fighters Clash',
					'Sonic the Hedgehog Pocket Adventure',
					'Metal Slug - 2nd Mission',
					'Metal Slug - 1st Mission',
					'King of Fighters R-2',
					'Last Blade',
					'Gals\' Fighters',
					'Samurai Shodown! 2',
					'Fatal Fury - First Contact',
					'Neo Turf Masters',
					'Baseball Stars Color',
					'Dark Arms - Beast Buster',
					'Faselei!',
					'Biomotor Unitron',
					'Rockman Battle & Fighters',
					'Bust-A-Move Pocket',
					'Puyo Pop',
					'Puzzle Link 2',
					'Pac-Man',
					'Cotton',
					'Cool Cool Jam',
					'Dive Alert',
					'Evolution - Eternal Dungeons',
					'Ogre Battle Gaiden'
				],
				'NDS': [
					'Pokemon HeartGold',
					'Pokemon SoulSilver',
					'Legend of Zelda, The - Phantom Hourglass',
					'Legend of Zelda, The - Spirit Tracks',
					'Chrono Trigger',
					'Mario Kart DS',
					'New Super Mario Bros.',
					'Super Mario 64 DS',
					'Mario & Luigi - Bowser\'s Inside Story',
					'Pokemon Black',
					'Pokemon White',
					'Pokemon Platinum',
					'Advance Wars - Dual Strike',
					'Final Fantasy Tactics A2 - Grimoire of the Rift',
					'Dragon Quest IX - Sentinels of the Starry Skies',
					'Castlevania - Dawn of Sorrow',
					'Castlevania - Portrait of Ruin',
					'Castlevania - Order of Ecclesia',
					'Professor Layton and the Curious Village',
					'Professor Layton and the Unwound Future',
					'Phoenix Wright - Ace Attorney',
					'Ghost Trick - Phantom Detective',
					'Kirby Super Star Ultra',
					'Metroid Prime Hunters',
					'Advance Wars - Days of Ruin'
				],
				'PSP': [
					'God of War - Chains of Olympus',
					'God of War - Ghost of Sparta',
					'Metal Gear Solid - Peace Walker',
					'Grand Theft Auto - Liberty City Stories',
					'Grand Theft Auto - Vice City Stories',
					'Final Fantasy Tactics - The War of the Lions',
					'Crisis Core - Final Fantasy VII',
					'Persona 3 Portable',
					'Tactics Ogre - Let Us Cling Together',
					'Daxter',
					'Ratchet & Clank - Size Matters',
					'Lumines',
					'Patapon',
					'Patapon 2',
					'LocoRoco',
					'LocoRoco 2',
					'Monster Hunter Freedom Unite',
					'Tekken - Dark Resurrection',
					'Soulcalibur - Broken Destiny',
					'Disgaea - Afternoon of Darkness',
					'Valkyria Chronicles II',
					'Jeanne d\'Arc',
					'Ys Seven',
					'Killzone - Liberation',
					'Resistance - Retribution'
				],
				'Saturn': [
					'Panzer Dragoon Saga',
					'Panzer Dragoon Zwei',
					'Panzer Dragoon',
					'NiGHTS Into Dreams',
					'Guardian Heroes',
					'Radiant Silvergun',
					'Shining Force III',
					'Burning Rangers',
					'Saturn Bomberman',
					'Virtua Fighter 2',
					'Virtua Cop',
					'Virtua Cop 2',
					'Sega Rally Championship',
					'Daytona USA',
					'Sonic Jam',
					'Sonic R',
					'Fighters Megamix',
					'Fighting Vipers',
					'Die Hard Arcade',
					'The House of the Dead',
					'Grandia',
					'Lunar - Silver Star Story Complete',
					'Resident Evil',
					'Street Fighter Alpha 2',
					'Marvel vs. Capcom'
				],
				'Dreamcast': [
					'Sonic Adventure',
					'Sonic Adventure 2',
					'Shenmue',
					'Shenmue II',
					'Jet Grind Radio',
					'Crazy Taxi',
					'Crazy Taxi 2',
					'SoulCalibur',
					'Marvel vs. Capcom 2',
					'Power Stone',
					'Power Stone 2',
					'Resident Evil - Code Veronica',
					'Skies of Arcadia',
					'Grandia II',
					'Phantasy Star Online',
					'Ikaruga',
					'Bangai-O',
					'Rez',
					'Space Channel 5',
					'Seaman',
					'Samba de Amigo',
					'Virtua Tennis',
					'NFL 2K1',
					'Tony Hawk\'s Pro Skater 2',
					'Dead or Alive 2'
				],
				'Sega CD': [
					'Sonic CD',
					'Snatcher',
					'Lunar - The Silver Star',
					'Lunar - Eternal Blue',
					'Silpheed',
					'Popful Mail',
					'Shining Force CD',
					'Vay',
					'Final Fight CD',
					'Robo Aleste',
					'Lords of Thunder',
					'Keio Flying Squadron',
					'The Ninja Warriors',
					'Batman Returns',
					'Ecco the Dolphin',
					'Ecco - The Tides of Time',
					'Heart of the Alien',
					'Earthworm Jim - Special Edition',
					'Mansion of Hidden Souls',
					'Night Trap',
					'Sewer Shark',
					'Ground Zero Texas',
					'Fahrenheit',
					'Dark Wizard',
					'Mickey Mania'
				],
				'Sega 32X': [
					'Knuckles\' Chaotix',
					'Kolibri',
					'Star Wars Arcade',
					'Virtua Fighter',
					'Virtua Racing Deluxe',
					'Doom',
					'After Burner Complete',
					'Shadow Squadron',
					'Metal Head',
					'Tempo',
					'Zaxxon\'s Motherbase 2000',
					'Blackthorne',
					'NBA Jam Tournament Edition',
					'Mortal Kombat II',
					'WWF WrestleMania - The Arcade Game',
					'Space Harrier',
					'Star Trek - Starfleet Academy',
					'Golf Magazine - 36 Great Holes',
					'Motocross Championship',
					'Pitfall - The Mayan Adventure',
					'Primal Rage',
					'RBI Baseball \'95',
					'Spider-Man - Web of Fire',
					'Surgical Strike',
					'Cosmic Carnage'
				],
				'Atari 5200': [
					'Pitfall II - Lost Caverns',
					'Pengo',
					'Moon Patrol',
					'Jungle Hunt',
					'Joust',
					'Robotron - 2084',
					'Ms. Pac-Man',
					'Pac-Man',
					'Dig Dug',
					'Centipede',
					'Defender',
					'Missile Command',
					'Galaxian',
					'Frogger',
					'Gyruss',
					'Pole Position',
					'Space Invaders',
					'Berzerk',
					'Qix',
					'Kangaroo',
					'Wizard of Wor',
					'Star Raiders',
					'Choplifter',
					'Bounty Bob Strikes Back',
					'Jr. Pac-Man'
				],
				'Atari 7800': [
					'Alien Brigade',
					'Asteroids',
					'Basketbrawl',
					'Centipede',
					'Choplifter',
					'Commando',
					'Dark Chambers',
					'Dig Dug',
					'Donkey Kong',
					'Donkey Kong Junior',
					'Food Fight',
					'Galaga',
					'Ikari Warriors',
					'Joust',
					'Mario Bros.',
					'Mat Mania Challenge',
					'Ms. Pac-Man',
					'Ninja Golf',
					'Pole Position II',
					'Rampage',
					'Robotron - 2084',
					'Scrapyard Dog',
					'Xevious',
					'Double Dragon',
					'Tower Toppler'
				],
				'Virtual Boy': [
					'Wario Land',
					'Mario\'s Tennis',
					'Teleroboxer',
					'Red Alarm',
					'Galactic Pinball',
					'Mario Clash',
					'Panic Bomber',
					'Vertical Force',
					'Jack Bros.',
					'3D Tetris',
					'Golf',
					'V-Tetris',
					'Nester\'s Funky Bowling',
					'Waterworld',
					'Space Invaders Virtual Collection'
				],
				'Coleco': [
					'Donkey Kong',
					'Ladybug',
					'Mouse Trap',
					'Zaxxon',
					'Venture',
					'Smurfs, The',
					'Cosmic Avenger',
					'Frogger',
					'Q*bert',
					'Burgertime',
					'Carnival',
					'Centipede',
					'Dig Dug',
					'Donkey Kong Jr.',
					'Frontline',
					'Gorf',
					'Jumpman Junior',
					'Looping',
					'Montezuma\'s Revenge',
					'Mr. Do!',
					'Pitfall!',
					'Popeye',
					'River Raid',
					'Smurf - Rescue in Gargamel\'s Castle',
					'Space Panic'
				],
				'Intellivision': [
					'Advanced Dungeons & Dragons',
					'TRON - Deadly Discs',
					'BurgerTime',
					'Astrosmash',
					'Sea Battle',
					'Space Armada',
					'Night Stalker',
					'Thunder Castle',
					'Advanced Dungeons & Dragons - Treasure of Tarmin',
					'B-17 Bomber',
					'Beauty & The Beast',
					'Bump \'N\' Jump',
					'Demon Attack',
					'Frog Bog',
					'Microsurgeon',
					'Mission X',
					'Mouse Trap',
					'Q*bert',
					'Snafu',
					'Space Battle',
					'Space Hawk',
					'Sub Hunt',
					'Tower of Doom',
					'Utopia',
					'Vectron'
				],
				'Vectrex': [
					'Armor Attack',
					'Berzerk',
					'Cosmic Chasm',
					'Fortress of Narzod',
					'Hyperchase',
					'Mine Storm',
					'Pole Position',
					'Rip Off',
					'Solar Quest',
					'Space Wars',
					'Spike',
					'Star Castle',
					'Star Trek',
					'Web Wars',
					'Bedlam',
					'Blitz!',
					'Clean Sweep',
					'Engine Analyzer',
					'Heads Up',
					'Scramble',
					'Star Hawk',
					'Spinball',
					'Starhawk',
					'Tour De France',
					'Vectrex Baseball'
				],
				'3DO': [
					'Star Control II',
					'Road Rash',
					'Super Street Fighter II Turbo',
					'Gex',
					'Need for Speed',
					'The Horde',
					'Twisted - The Game Show',
					'Crash \'N Burn',
					'Way of the Warrior',
					'Alone in the Dark',
					'D',
					'Samurai Shodown',
					'Shock Wave',
					'Return Fire',
					'Guardian War',
					'Out of This World',
					'Night Trap',
					'Dragon\'s Lair',
					'Theme Park',
					'FIFA International Soccer',
					'Blade Force',
					'Total Eclipse',
					'Quarantine',
					'Slayer',
					'Star Fighter'
				],
				'Amiga': [
					'Sensible World of Soccer',
					'Cannon Fodder',
					'Lemmings',
					'Speedball 2 - Brutal Deluxe',
					'The Secret of Monkey Island',
					'Monkey Island 2 - LeChuck\'s Revenge',
					'Another World',
					'Flashback',
					'Beneath a Steel Sky',
					'Civilization',
					'Syndicate',
					'UFO - Enemy Unknown',
					'Kick Off 2',
					'Dune II',
					'Populous',
					'Shadow of the Beast',
					'Turrican II',
					'Stunt Car Racer',
					'Rainbow Islands',
					'The Chaos Engine',
					'Worms',
					'Pinball Dreams',
					'Gods',
					'Xenon 2 - Megablast',
					'It Came from the Desert'
				],
				'Commodore 64': [
					'The Last Ninja',
					'Boulder Dash',
					'Impossible Mission',
					'Maniac Mansion',
					'Pirates!',
					'Wizball',
					'Turrican',
					'R-Type',
					'International Karate +',
					'Bubble Bobble',
					'Paradroid',
					'The Great Giana Sisters',
					'Jet Set Willy',
					'Elite',
					'Mayhem in Monsterland',
					'Summer Games',
					'California Games',
					'Wasteland',
					'M.U.L.E.',
					'Ghostbusters',
					'Bruce Lee',
					'Prince of Persia',
					'Laser Squad',
					'Raid on Bungeling Bay',
					'Archon'
				]
			};

			// IndexedDB for persisting directory handle and device
			const DB_NAME = 'NanoArcade';
			const DB_VERSION = 2;
			const STORE_NAME = 'handles';

			function openDB() {
				return new Promise((resolve, reject) => {
					const request = indexedDB.open(DB_NAME, DB_VERSION);
					request.onerror = () => reject(request.error);
					request.onsuccess = () => resolve(request.result);
					request.onupgradeneeded = (e) => {
						const db = e.target.result;
						if (!db.objectStoreNames.contains(STORE_NAME)) {
							db.createObjectStore(STORE_NAME);
						}
					};
				});
			}

			async function saveHandle(handle) {
				const db = await openDB();
				return new Promise((resolve, reject) => {
					const tx = db.transaction(STORE_NAME, 'readwrite');
					tx.objectStore(STORE_NAME).put(handle, 'directoryHandle');
					tx.oncomplete = () => resolve();
					tx.onerror = () => reject(tx.error);
				});
			}

			async function saveDevice(device) {
				const db = await openDB();
				return new Promise((resolve, reject) => {
					const tx = db.transaction(STORE_NAME, 'readwrite');
					tx.objectStore(STORE_NAME).put(device, 'deviceType');
					tx.oncomplete = () => resolve();
					tx.onerror = () => reject(tx.error);
				});
			}

			async function getSavedHandle() {
				const db = await openDB();
				return new Promise((resolve, reject) => {
					const tx = db.transaction(STORE_NAME, 'readonly');
					const request = tx.objectStore(STORE_NAME).get('directoryHandle');
					request.onsuccess = () => resolve(request.result);
					request.onerror = () => reject(request.error);
				});
			}

			async function getSavedDevice() {
				const db = await openDB();
				return new Promise((resolve, reject) => {
					const tx = db.transaction(STORE_NAME, 'readonly');
					const request = tx.objectStore(STORE_NAME).get('deviceType');
					request.onsuccess = () => resolve(request.result || 'rgnano');
					request.onerror = () => reject(request.error);
				});
			}

			async function tryRestoreHandle() {
				try {
					const savedDevice = await getSavedDevice();
					if (savedDevice) {
						currentDevice = savedDevice;
					}
					const savedHandle = await getSavedHandle();
					if (savedHandle) {
						// Request permission on the saved handle
						const permission = await savedHandle.requestPermission({ mode: 'readwrite' });
						if (permission === 'granted') {
							directoryHandle = savedHandle;
							updateDeviceIndicator();
							await scanExistingDirectory();
							return true;
						}
					}
				} catch (e) {
					// Handle could not be restored (permission denied or directory moved)
				}
				return false;
			}

			function updateDeviceIndicator() {
				// Device name is now shown in the sidebar Home link
				renderConsoleList();
			}

			// Show device selection modal
			function showDeviceSelector() {
				// Check if File System Access API is supported
				if (!window.showDirectoryPicker) {
					showUnsupportedBrowserModal();
					return;
				}
				document.getElementById('deviceModal').classList.add('active');
			}

			function showUnsupportedBrowserModal() {
				// Show the dedicated unsupported browser modal
				document.getElementById('unsupportedBrowserModal').classList.add('active');
			}

			// Select device and continue with folder scan
			function showMinUIResolutionModal() {
				closeModal('deviceModal');
				document.getElementById('minuiResolutionModal').classList.add('active');
			}

			function selectMinUIResolution(deviceType) {
				closeModal('minuiResolutionModal');
				selectDevice(deviceType);
			}

			function showNextUIResolutionModal() {
				closeModal('deviceModal');
				document.getElementById('nextuiResolutionModal').classList.add('active');
			}

			function selectNextUIResolution(deviceType) {
				closeModal('nextuiResolutionModal');
				selectDevice(deviceType);
			}

			async function selectDevice(deviceType) {
				currentDevice = deviceType;
				await saveDevice(deviceType);
				closeModal('deviceModal');
				updateDeviceIndicator();

				// Clear existing handle and always open folder picker
				directoryHandle = null;
				consoles = {};
				renderConsoleList();

				// Show device-specific folder selection instructions in modal
				const profile = deviceProfiles[deviceType];
				let message = '';
				if (profile.catalogueStructure) {
					// Trimui Brick / Mustard OS
					message = 'Please select the <strong>ROOT of your SD card</strong> (the folder containing the MUOS folder)';
				} else if (profile.isMinUI || profile.isNextUI) {
					// MinUI / NextUI
					message = 'Please select the <strong>ROOT of your SD card</strong><br><small style="color: rgba(255,255,255,0.6);">The folder containing the Roms folder</small>';
				} else if (profile.emoji === 'ðŸ§…') {
					// Miyoo devices with Onion OS - select root so we can access Saves folder too
					message = 'Please select the <strong>ROOT of your SD card</strong><br><small style="color: rgba(255,255,255,0.6);">The folder containing Roms, Saves, RetroArch, etc.</small>';
				} else if (deviceType === 'rgnano') {
					// RG Nano with Drum78 CFW
					message = 'Please select the <strong>ROOT of your SD card</strong><br><small style="color: rgba(255,255,255,0.6);">Your system folders (GB, GBA, NES, etc.) should be at the root level</small>';
				} else {
					// Generic device
					message = 'Please select your <strong>ROMs folder</strong> (the folder containing your console subfolders like GB, GBA, SNES, etc.)';
				}
				document.getElementById('folderInstructionText').innerHTML = message;
				document.getElementById('folderInstructionsModal').classList.add('active');
			}

			async function closeInstructionsAndScan() {
				closeModal('folderInstructionsModal');
				await scanDrive();
			}

			// Recursive helper to scan for ROM files in a directory and its subdirectories
			async function scanForRomFiles(dirHandle, basePath = '', depth = 0) {
				const MAX_DEPTH = 10; // Prevent infinite recursion
				if (depth > MAX_DEPTH) return [];

				const files = [];
				const skipExts = ['.png', '.jpg', '.jpeg', '.txt', '.cue', '.m3u', '.srm', '.sav', '.xml', '.json', '.db', '.cfg'];
				const skipNames = ['gamelist', 'miyoogamelist'];

				for await (const entry of dirHandle.values()) {
					if (entry.kind === 'file') {
						// Skip files without extensions
						if (!entry.name.includes('.')) continue;

						const ext = '.' + entry.name.split('.').pop().toLowerCase();
						const lowerName = entry.name.toLowerCase();
						const isSkipName = skipNames.some(s => lowerName.startsWith(s));

						if (!skipExts.includes(ext) && !isSkipName) {
							const relativePath = basePath ? basePath + '/' + entry.name : entry.name;
							files.push({
								name: entry.name,
								relativePath: relativePath,
								dirHandle: dirHandle
							});
						}
					} else if (entry.kind === 'directory') {
						// Recursively scan subdirectories
						try {
							const subDir = await dirHandle.getDirectoryHandle(entry.name);
							const subPath = basePath ? basePath + '/' + entry.name : entry.name;
							const subFiles = await scanForRomFiles(subDir, subPath, depth + 1);
							files.push(...subFiles);
						} catch (e) {
							// Skip inaccessible directories
						}
					}
				}

				return files;
			}

			async function scanExistingDirectory() {
				if (!directoryHandle) return;
				consoles = {};
				const profile = deviceProfiles[currentDevice];
				const usesImgsFolder = profile.emoji === 'ðŸ§…'; // Onion OS devices use Imgs subfolder
				const usesCatalogueStructure = profile.catalogueStructure === true; // Trimui Brick / Mustard OS

				if (usesCatalogueStructure) {
					// MustardOS: ROMs in ROMS/<folder>/, box art in MUOS/info/catalogue/<system>/box/
					// Mapping from common ROM folder names to MustardOS catalogue system names
					const muosCatalogueMap = {
						'gba': 'Nintendo Game Boy Advance',
						'gb': 'Nintendo Game Boy',
						'gbc': 'Nintendo Game Boy',
						'nds': 'Nintendo DS',
						'ds': 'Nintendo DS',
						'nes': 'Nintendo NES - Famicom',
						'fc': 'Nintendo NES - Famicom',
						'famicom': 'Nintendo NES - Famicom',
						'snes': 'Nintendo SNES - SFC',
						'sfc': 'Nintendo SNES - SFC',
						'md': 'Sega Mega Drive - Genesis',
						'genesis': 'Sega Mega Drive - Genesis',
						'megadrive': 'Sega Mega Drive - Genesis',
						'ps': 'Sony PlayStation',
						'ps1': 'Sony PlayStation',
						'psx': 'Sony PlayStation',
						'playstation': 'Sony PlayStation',
						'pico': 'Sega Pico',
						'n64': 'Nintendo N64',
						'arcade': 'Arcade',
						'cps1': 'Arcade',
						'cps2': 'Arcade',
						'cps3': 'Arcade',
						'neogeo': 'SNK Neo Geo',
						'pce': 'NEC PC Engine - TurboGrafx 16',
						'pcengine': 'NEC PC Engine - TurboGrafx 16',
						'gg': 'Sega Game Gear',
						'gamegear': 'Sega Game Gear',
						'sms': 'Sega Master System',
						'mastersystem': 'Sega Master System',
						'scummvm': 'ScummVM',
						'fds': 'Nintendo Famicom Disk System',
						'vb': 'Nintendo Virtual Boy',
						'virtualboy': 'Nintendo Virtual Boy',
						'pokemini': 'Nintendo Pokemon Mini',
						'wswan': 'Bandai WonderSwan',
						'wswanc': 'Bandai WonderSwan Color',
						'ngp': 'SNK Neo Geo Pocket',
						'ngpc': 'SNK Neo Geo Pocket Color',
						'atari2600': 'Atari 2600',
						'atari7800': 'Atari 7800',
						'lynx': 'Atari Lynx',
						'coleco': 'ColecoVision',
						'msx': 'Microsoft MSX',
						'vectrex': 'GCE Vectrex'
					};

					try {
						// Get ROMS folder
						let romsDir;
						try {
							romsDir = await directoryHandle.getDirectoryHandle('ROMS');
						} catch {
							// Try lowercase
							romsDir = await directoryHandle.getDirectoryHandle('roms');
						}

						// Get catalogue directory for box art
						let catalogueDir = null;
						try {
							const muosDir = await directoryHandle.getDirectoryHandle('MUOS');
							const infoDir = await muosDir.getDirectoryHandle('info');
							catalogueDir = await infoDir.getDirectoryHandle('catalogue');
						} catch {
							// Catalogue not found, will work without box art
						}

						// Scan ROMS folder for system subfolders
						for await (const romFolderEntry of romsDir.values()) {
							if (romFolderEntry.kind === 'directory') {
								const folderName = romFolderEntry.name;
								const games = [];

								try {
									const romFolder = await romsDir.getDirectoryHandle(folderName);

									// Find matching catalogue system for box art
									const catalogueName = muosCatalogueMap[folderName.toLowerCase()] || folderName;
									let boxDir = null;
									if (catalogueDir) {
										try {
											const catalogueSystemDir = await catalogueDir.getDirectoryHandle(catalogueName);
											boxDir = await catalogueSystemDir.getDirectoryHandle('box');
										} catch {
											// Try exact folder name as fallback
											try {
												const catalogueSystemDir = await catalogueDir.getDirectoryHandle(folderName);
												boxDir = await catalogueSystemDir.getDirectoryHandle('box');
											} catch {}
										}
									}

									// Scan for ROM files (including subdirectories)
									const romFiles = await scanForRomFiles(romFolder);
									for (const fileInfo of romFiles) {
										const baseName = fileInfo.name.substring(0, fileInfo.name.lastIndexOf('.'));
										let hasImage = false;
										let imageExt = null;

										// Check for images in multiple locations:
										// 1. Box folder (MustardOS standard location)
										// 2. Same directory as the ROM file (for games in subfolders)
										const imageDirs = boxDir ? [boxDir, fileInfo.dirHandle] : [fileInfo.dirHandle];

										for (const imgDir of imageDirs) {
											if (hasImage) break;
											try {
												await imgDir.getFileHandle(baseName + '.png');
												hasImage = true;
												imageExt = '.png';
											} catch {
												try {
													await imgDir.getFileHandle(baseName + '.jpg');
													hasImage = true;
													imageExt = '.jpg';
												} catch {}
											}
										}

										games.push({
											name: fileInfo.name,
											baseName,
											hasImage,
											imageExt,
											relativePath: fileInfo.relativePath,
											dirHandle: fileInfo.dirHandle
										});
									}

									if (games.length > 0) {
										// Use a display name based on catalogue or folder name
										const displayName = catalogueName !== folderName ? catalogueName : folderName;
										consoles[displayName] = {
											handle: romFolder,
											boxHandle: boxDir,
											catalogueName: catalogueName,
											romFolderName: folderName,
											games: games.sort((a, b) => a.baseName.localeCompare(b.baseName))
										};
									}
								} catch (e) { /* Could not access ROM folder */ }
							}
						}
					} catch (e) {
						showError('ROMS folder not found. Please select the root of your SD card (the folder containing both ROMS and MUOS folders).');
						return;
					}
				} else {
					// Standard scanning for other devices
					// Skip folders that are apps/system folders, not console ROM folders
					const skipFolders = [
						'funkey', '.picoarch', 'wolfenstein 3d', 'doom', 'quake',
						'system', 'bios', 'save', 'saves', 'config', 'retroarch',
						'app', 'miyoo', 'retroarch', 'themes', 'media', 'emu', 'screenshots', 'icons', '.tmp_update'
					];

					// For Onion OS and MinUI/NextUI devices, scan the Roms subfolder instead of root
					let scanDir = directoryHandle;
					if (usesImgsFolder || profile.isMinUI || profile.isNextUI) {
						try {
							scanDir = await directoryHandle.getDirectoryHandle('Roms');
						} catch {
							try {
								scanDir = await directoryHandle.getDirectoryHandle('ROMS');
							} catch {
								try {
									scanDir = await directoryHandle.getDirectoryHandle('roms');
								} catch {
									showError('Roms folder not found. Please select the root of your SD card (the folder containing the Roms folder).');
									return;
								}
							}
						}
					}

					for await (const entry of scanDir.values()) {
						if (entry.kind === 'directory') {
							const consoleName = entry.name;
							// Skip known non-console folders
							if (skipFolders.includes(consoleName.toLowerCase())) continue;

							const games = [];
							try {
								const consoleDir = await scanDir.getDirectoryHandle(consoleName);
								// Check for device-specific image folders
								let imgsDir = null;
								let resDir = null;
								let mediaDir = null;

								if (usesImgsFolder) {
									// Onion OS: Check for Imgs subfolder
									try {
										imgsDir = await consoleDir.getDirectoryHandle('Imgs');
									} catch {}
								} else if (profile.isMinUI) {
									// MinUI: Check for .res subfolder
									try {
										resDir = await consoleDir.getDirectoryHandle('.res');
									} catch {}
								} else if (profile.isNextUI) {
									// NextUI: Check for .media subfolder
									try {
										mediaDir = await consoleDir.getDirectoryHandle('.media');
									} catch {}
								}

								const imageDir = imgsDir || resDir || mediaDir || consoleDir;

								// Scan for ROM files (including subdirectories)
								const romFiles = await scanForRomFiles(consoleDir);
								for (const fileInfo of romFiles) {
									const baseName = fileInfo.name.substring(0, fileInfo.name.lastIndexOf('.'));
									let hasImage = false;
									let imageExt = null;

									// Check for images in multiple locations:
									// 1. Same directory as the ROM file (for games in subfolders)
									// 2. Standard image directory (Imgs/.res/.media folder or console root)
									const imageDirs = [fileInfo.dirHandle, imageDir];

									for (const imgDir of imageDirs) {
										if (hasImage) break;

										// For MinUI, check with ROM extension included (e.g., "Pokemon Red.gb.png")
										if (profile.isMinUI) {
											try {
												await imgDir.getFileHandle(fileInfo.name + '.png');
												hasImage = true;
												imageExt = '.png';
											} catch {
												try {
													await imgDir.getFileHandle(fileInfo.name + '.jpg');
													hasImage = true;
													imageExt = '.jpg';
												} catch {}
											}
										}

										// For all other devices (including NextUI), check without ROM extension
										if (!hasImage) {
											try {
												await imgDir.getFileHandle(baseName + '.png');
												hasImage = true;
												imageExt = '.png';
											} catch {
												try {
													await imgDir.getFileHandle(baseName + '.jpg');
													hasImage = true;
													imageExt = '.jpg';
												} catch {}
											}
										}
									}

									games.push({
										name: fileInfo.name,
										baseName,
										hasImage,
										imageExt,
										relativePath: fileInfo.relativePath,
										dirHandle: fileInfo.dirHandle
									});
								}
								if (games.length > 0) {
									consoles[consoleName] = {
										handle: consoleDir,
										imgsHandle: imgsDir,
										resHandle: resDir,
										mediaHandle: mediaDir,
										games: games.sort((a, b) => a.baseName.localeCompare(b.baseName))
									};
								}
							} catch (e) { /* Could not access directory */ }
						}
					}
				}
				renderConsoleList();
				updateStats();
			}

			// Try to restore on page load
			window.addEventListener('DOMContentLoaded', async () => {
				await tryRestoreHandle();
			});

			// Console icons mapping
			const consoleIcons = {
				// Nintendo handhelds
				'game boy': 'icons/gb.png',
				'gb': 'icons/gb.png',
				'game boy color': 'icons/gbc.png',
				'gbc': 'icons/gbc.png',
				'game boy advance': 'icons/gba.png',
				'gba': 'icons/gba.png',
				'super game boy': 'icons/sgb.png',
				'sgb': 'icons/sgb.png',
				'nds': 'icons/nds.png',
				'nintendo ds': 'icons/nds.png',
				'ds': 'icons/nds.png',
				'virtual boy': 'icons/vb.png',
				'vb': 'icons/vb.png',
				// Nintendo consoles
				'nes': 'icons/fc.png',
				'famicom': 'icons/fc.png',
				'fc': 'icons/fc.png',
				'fds': 'icons/fds.png',
				'famicom disk system': 'icons/fds.png',
				'snes': 'icons/sfc.png',
				'super nintendo': 'icons/sfc.png',
				'super famicom': 'icons/sfc.png',
				'sfc': 'icons/sfc.png',
				'n64': 'icons/n64.png',
				'nintendo 64': 'icons/n64.png',
				// Sega
				'sega master system': 'icons/ms.png',
				'master system': 'icons/ms.png',
				'sms': 'icons/ms.png',
				'ms': 'icons/ms.png',
				'sega genesis': 'icons/md.png',
				'genesis': 'icons/md.png',
				'mega drive': 'icons/md.png',
				'md': 'icons/md.png',
				'sega cd': 'icons/segacd.png',
				'segacd': 'icons/segacd.png',
				'32x': 'icons/32x.png',
				'sega 32x': 'icons/32x.png',
				'dreamcast': 'icons/dc.png',
				'dc': 'icons/dc.png',
				'game gear': 'icons/gg.png',
				'gg': 'icons/gg.png',
				'gamegear': 'icons/gg.png',
				// Sony
				'playstation': 'icons/ps.png',
				'ps1': 'icons/ps.png',
				'psx': 'icons/ps.png',
				'ps': 'icons/ps.png',
				'psp': 'icons/psp.png',
				// NEC
				'pce': 'icons/pce.png',
				'pce-turbografx': 'icons/pce.png',
				'turbografx': 'icons/pce.png',
				'pc engine': 'icons/pce.png',
				'pcengine': 'icons/pce.png',
				'pce cd': 'icons/pcecd.png',
				'pcecd': 'icons/pcecd.png',
				'supergrafx': 'icons/sgfx.png',
				'sgfx': 'icons/sgfx.png',
				// SNK
				'neo geo': 'icons/neogeo.png',
				'neogeo': 'icons/neogeo.png',
				'neo geo cd': 'icons/neocd.png',
				'neocd': 'icons/neocd.png',
				'neo geo pocket': 'icons/ngp.png',
				'ngp': 'icons/ngp.png',
				'neo geo pocket color': 'icons/ngpc.png',
				'ngpc': 'icons/ngpc.png',
				// Atari
				'atari 2600': 'icons/atari.png',
				'atari2600': 'icons/atari.png',
				'atari 5200': 'icons/5200.png',
				'atari5200': 'icons/5200.png',
				'a5200': 'icons/5200.png',
				'atari 7800': 'icons/7800.png',
				'atari7800': 'icons/7800.png',
				'a7800': 'icons/7800.png',
				'atari lynx': 'icons/lynx.png',
				'lynx': 'icons/lynx.png',
				'atarilynx': 'icons/lynx.png',
				'atari 800': 'icons/atari800.png',
				'atari800': 'icons/atari800.png',
				'atari st': 'icons/atarist.png',
				'atarist': 'icons/atarist.png',
				// Bandai
				'wonderswan': 'icons/ws.png',
				'ws': 'icons/ws.png',
				'wonderswan color': 'icons/wsc.png',
				'wsc': 'icons/wsc.png',
				// Arcade
				'arcade': 'icons/arcade.png',
				'mame': 'icons/mame.png',
				'fba': 'icons/arcade.png',
				'fbneo': 'icons/arcade.png',
				'cps1': 'icons/cps1.png',
				'cps2': 'icons/cps2.png',
				'cps3': 'icons/cps3.png',
				// Computers
				'amiga': 'icons/amiga.png',
				'c64': 'icons/c64.png',
				'commodore 64': 'icons/c64.png',
				'dos': 'icons/dos.png',
				'dosbox': 'icons/dos.png',
				'msx': 'icons/msx.png',
				'x68000': 'icons/x68000.png',
				'zx spectrum': 'icons/zxs.png',
				'zxs': 'icons/zxs.png',
				'amstrad cpc': 'icons/cpc.png',
				'cpc': 'icons/cpc.png',
				// Other consoles
				'colecovision': 'icons/col.png',
				'col': 'icons/col.png',
				'intellivision': 'icons/itv.png',
				'intv': 'icons/itv.png',
				'itv': 'icons/itv.png',
				'vectrex': 'icons/vectrex.png',
				'odyssey': 'icons/ody.png',
				'ody': 'icons/ody.png',
				'fairchild': 'icons/fairchild.png',
				'channel f': 'icons/fairchild.png',
				// Misc
				'pico-8': 'icons/pico.png',
				'pico8': 'icons/pico.png',
				'pico': 'icons/pico.png',
				'pokemon mini': 'icons/poke.png',
				'pokemini': 'icons/poke.png',
				'poke': 'icons/poke.png',
				'game & watch': 'icons/gw.png',
				'gw': 'icons/gw.png',
				'arduboy': 'icons/arduboy.png',
				'scummvm': 'icons/scummvm.png',
				'openbor': 'icons/openbor.png',
				'tic-80': 'icons/tic.png',
				'tic80': 'icons/tic.png',
				'doom': 'icons/doom.png',
				'quake': 'icons/quake.png',
				'wolfenstein': 'icons/wolf.png',
				'supervision': 'icons/supervision.png',
				'megaduck': 'icons/megaduck.png',
				'ports': 'icons/ports.png',
				'default': 'icons/arcade.png'
			};

			// List of known gaming consoles (only these show in Consoles section)
			const knownConsoles = [
				// Nintendo
				'game boy', 'gb', 'game boy color', 'gbc', 'game boy advance', 'gba',
				'super game boy', 'sgb', 'virtual boy', 'vb',
				'nes', 'famicom', 'fc', 'fds', 'snes', 'super nintendo', 'super famicom', 'sfc',
				'n64', 'nintendo 64', 'nds', 'nintendo ds', 'ds',
				// Sega
				'sega master system', 'master system', 'sms', 'ms',
				'sega genesis', 'genesis', 'mega drive', 'md', 'sega cd', 'segacd', '32x',
				'dreamcast', 'dc', 'game gear', 'gg', 'gamegear',
				// Sony
				'playstation', 'ps1', 'psx', 'ps', 'psp',
				// NEC
				'pce', 'pce-turbografx', 'turbografx', 'pc engine', 'pcengine', 'pcecd', 'supergrafx', 'sgfx',
				// SNK
				'arcade', 'mame', 'fba', 'fbneo', 'cps1', 'cps2', 'cps3',
				'neo geo', 'neogeo', 'neocd', 'neo geo pocket', 'ngp', 'ngpc',
				// Atari
				'atari lynx', 'lynx', 'atarilynx', 'atari 2600', 'atari2600', 'atari 5200', 'a5200',
				'atari 7800', 'atari7800', 'a7800', 'atari 800', 'atari800', 'atari st', 'atarist',
				// Bandai
				'wonderswan', 'ws', 'wonderswan color', 'wsc',
				// Computers
				'amiga', 'c64', 'commodore 64', 'dos', 'dosbox', 'msx', 'x68000', 'zx spectrum', 'zxs', 'amstrad cpc', 'cpc',
				// Other
				'colecovision', 'col', 'intellivision', 'intv', 'itv', 'vectrex', 'odyssey', 'ody', 'fairchild', 'channel f',
				'pico-8', 'pico8', 'pico', 'pokemon mini', 'pokemini', 'poke',
				'game & watch', 'gw', 'arduboy', 'scummvm', 'openbor', 'tic-80', 'tic80',
				'doom', 'quake', 'wolfenstein', 'supervision', 'megaduck', 'ports'
			];

			function isConsole(name) {
				const lower = name.toLowerCase();
				return knownConsoles.some(c => lower === c || lower.includes(c) || c.includes(lower));
			}

			function getConsoleIcon(consoleName) {
				const lowerName = consoleName.toLowerCase();
				if (consoleIcons[lowerName]) return consoleIcons[lowerName];
				for (const [key, iconPath] of Object.entries(consoleIcons)) {
					if (key !== 'default' && (lowerName.includes(key) || key.includes(lowerName))) {
						return iconPath;
					}
				}
				return consoleIcons['default'];
			}

			// Display names for console folders (abbreviation -> full name)
			const consoleDisplayNames = {
				'gb': 'Game Boy',
				'gbc': 'Game Boy Color',
				'gba': 'Game Boy Advance',
				'sgb': 'Super Game Boy',
				'nes': 'NES',
				'fc': 'Famicom',
				'fds': 'Famicom Disk System',
				'snes': 'SNES',
				'sfc': 'Super Famicom',
				'n64': 'Nintendo 64',
				'nds': 'Nintendo DS',
				'ds': 'Nintendo DS',
				'vb': 'Virtual Boy',
				'ms': 'Master System',
				'sms': 'Master System',
				'md': 'Mega Drive',
				'genesis': 'Genesis',
				'gg': 'Game Gear',
				'gamegear': 'Game Gear',
				'dc': 'Dreamcast',
				'segacd': 'Sega CD',
				'32x': 'Sega 32X',
				'ps': 'PlayStation',
				'psx': 'PlayStation',
				'ps1': 'PlayStation',
				'psp': 'PSP',
				'pce': 'PC Engine',
				'pcengine': 'PC Engine',
				'pcecd': 'PC Engine CD',
				'sgfx': 'SuperGrafx',
				'neogeo': 'Neo Geo',
				'neocd': 'Neo Geo CD',
				'ngp': 'Neo Geo Pocket',
				'ngpc': 'Neo Geo Pocket Color',
				'arcade': 'Arcade',
				'mame': 'Arcade (MAME)',
				'fbneo': 'Arcade (FBNeo)',
				'cps1': 'CPS1',
				'cps2': 'CPS2',
				'cps3': 'CPS3',
				'lynx': 'Atari Lynx',
				'atarilynx': 'Atari Lynx',
				'atari2600': 'Atari 2600',
				'a5200': 'Atari 5200',
				'atari5200': 'Atari 5200',
				'a7800': 'Atari 7800',
				'atari7800': 'Atari 7800',
				'atari800': 'Atari 800',
				'atarist': 'Atari ST',
				'ws': 'WonderSwan',
				'wsc': 'WonderSwan Color',
				'col': 'ColecoVision',
				'colecovision': 'ColecoVision',
				'intv': 'Intellivision',
				'itv': 'Intellivision',
				'vectrex': 'Vectrex',
				'ody': 'Odyssey',
				'fairchild': 'Fairchild Channel F',
				'amiga': 'Amiga',
				'c64': 'Commodore 64',
				'dos': 'DOS',
				'msx': 'MSX',
				'x68000': 'X68000',
				'zxs': 'ZX Spectrum',
				'cpc': 'Amstrad CPC',
				'pico': 'PICO-8',
				'pico8': 'PICO-8',
				'poke': 'Pokemon Mini',
				'pokemini': 'Pokemon Mini',
				'gw': 'Game & Watch',
				'arduboy': 'Arduboy',
				'scummvm': 'ScummVM',
				'openbor': 'OpenBOR',
				'tic': 'TIC-80',
				'doom': 'Doom',
				'quake': 'Quake',
				'supervision': 'Supervision',
				'megaduck': 'Mega Duck',
				'ports': 'Ports'
			};

			function getConsoleDisplayName(folderName) {
				const lower = folderName.toLowerCase();
				return consoleDisplayNames[lower] || folderName;
			}

			// Name cleanup patterns
			const cleanupPatterns = [
				/\s*\(USA\)/gi, /\s*\(Europe\)/gi, /\s*\(Japan\)/gi, /\s*\(World\)/gi,
				/\s*\(USA,\s*Europe\)/gi, /\s*\(En,?[A-Za-z,\s]*\)/gi,
				/\s*\(Rev\s*\d*\)/gi, /\s*\(SGB Enhanced\)/gi, /\s*\(GB Compatible\)/gi,
				/\s*\[!\]/gi, /\s*\[C\]/gi, /\s*\(V?\d+\.\d+\)/gi,
				/\s*\(Hack[^)]*\)/gi, /\s*\(Beta[^)]*\)/gi, /\s*\(Proto[^)]*\)/gi,
				/\s*\(Unl\)/gi, /\s*\(PD\)/gi, /\s*\(M\d+\)/gi, /\s+/g,
			];

			function cleanGameName(filename) {
				let name = filename;
				const lastDot = name.lastIndexOf('.');
				const ext = lastDot > 0 ? name.substring(lastDot) : '';
				name = lastDot > 0 ? name.substring(0, lastDot) : name;
				for (const pattern of cleanupPatterns) {
					name = name.replace(pattern, pattern.source === '\\s+' ? ' ' : '');
				}
				return name.trim() + ext;
			}

			async function scanDrive() {
				try {
					const handle = await window.showDirectoryPicker({ mode: 'readwrite' });
					directoryHandle = handle;
					await saveHandle(directoryHandle);
					await scanExistingDirectory();
				} catch (e) {
					// User cancelled the folder picker - don't show error
					if (e.name === 'AbortError') {
						return;
					}
					// Show error modal for other errors
					showError('Error scanning directory: ' + e.message);
				}
			}

			function showError(message) {
				document.getElementById('errorMessage').textContent = message;
				document.getElementById('errorModal').classList.add('active');
			}

			function renderConsoleList() {
				const list = document.getElementById('consoleList');
				const allFolders = Object.keys(consoles).sort();
				const consoleFolders = allFolders.filter(n => isConsole(n));

				// Calculate total games and missing across all consoles
				let totalGames = 0, totalMissing = 0;
				for (const name of consoleFolders) {
					totalGames += consoles[name].games.length;
					totalMissing += consoles[name].games.filter(g => !g.hasImage).length;
				}

				// Show device name next to Home if a device is selected
			const profile = currentDevice ? deviceProfiles[currentDevice] : null;
			const deviceLabel = profile ? ` <span style="opacity: 0.6; font-size: 0.9em;">- ${profile.emoji} ${profile.name}</span>` : '';
			let html = `<li><a href="javascript:void(0)" onclick="showHome()"><span class="icon solid fa-home"></span> Home${deviceLabel}</a></li>`;

				// Add "All Games" option if there are any games
				if (totalGames > 0) {
					html += `<li><a href="javascript:void(0)" onclick="selectAllGames()">
						<span class="icon solid fa-gamepad" style="width: 36px; height: 36px; display: inline-flex; align-items: center; justify-content: center; margin-right: 12px; font-size: 1.5em; flex-shrink: 0;"></span>
						<span>All Games</span>
						<span class="game-count">${totalGames}${totalMissing > 0 ? ' <span class="missing-art-count" title="' + totalMissing + ' games missing box art"><span class="icon solid fa-image"></span>' + totalMissing + '</span>' : ''}</span>
					</a></li>`;
				}

				// Console entries only
				for (const name of consoleFolders) {
					const count = consoles[name].games.length;
					const missing = consoles[name].games.filter(g => !g.hasImage).length;
					const icon = getConsoleIcon(name);
					const displayName = getConsoleDisplayName(name);
					html += `<li><a href="javascript:void(0)" onclick="selectConsole('${name.replace(/'/g, "\\'")}')">
						<img src="${icon}" class="console-icon" alt="${displayName}">
						<span>${displayName}</span>
						<span class="game-count">${count}${missing > 0 ? ' <span class="missing-art-count" title="' + missing + ' games missing box art"><span class="icon solid fa-image"></span>' + missing + '</span>' : ''}</span>
					</a></li>`;
				}

				list.innerHTML = html;

				const uploadSelect = document.getElementById('uploadConsoleSelect');
				uploadSelect.innerHTML = '<option value="">Select a console...</option>' +
					allFolders.map(n => `<option value="${n}">${getConsoleDisplayName(n)}</option>`).join('');
			}

			function updateStats() {
				let games = 0, missing = 0, consoleCount = 0;
				for (const [name, c] of Object.entries(consoles)) {
					if (isConsole(name)) {
						consoleCount++;
						games += c.games.length;
						missing += c.games.filter(g => !g.hasImage).length;
					}
				}
				document.getElementById('statConsoles').textContent = consoleCount;
				document.getElementById('statGames').textContent = games;
				document.getElementById('statMissing').textContent = missing;
				document.getElementById('statsRow').style.display = 'flex';
			}

			async function selectConsole(name) {
				currentConsole = name;
				const displayName = getConsoleDisplayName(name);
				document.getElementById('currentConsoleName').textContent = displayName;
				// Set console icon in header
				const iconEl = document.getElementById('currentConsoleIcon');
				iconEl.src = getConsoleIcon(name);
				iconEl.alt = displayName;
				iconEl.style.display = 'block';
				document.getElementById('floatingUpload').classList.add('visible');
				// Hide intro, show games
				document.getElementById('intro').style.display = 'none';
				document.getElementById('games').style.display = 'block';
				// Hide install button when leaving intro
				document.getElementById('installPwaBtn').style.display = 'none';
				// Show loading spinner
				const grid = document.getElementById('gamesGrid');
				grid.innerHTML = '<div class="loading-container"><div class="spinner"></div><div class="loading-text">Loading games...</div></div>';
				window.scrollTo(0, 0);
				// Small delay to let the spinner render before heavy work
				await new Promise(r => setTimeout(r, 50));
				// Update game count badge and Top 25 button visibility
				updateGameCountBadge();
				updateTop25Button();
				updateBatchLibretroButton();
				await renderGames();
			}

			async function selectAllGames() {
				currentConsole = '__all__';
				document.getElementById('currentConsoleName').textContent = 'All Games';
				// Hide console icon for All Games view
				document.getElementById('currentConsoleIcon').style.display = 'none';
				document.getElementById('floatingUpload').classList.add('visible');
				// Hide intro, show games, hide install button
				document.getElementById('intro').style.display = 'none';
				document.getElementById('installPwaBtn').style.display = 'none';
				document.getElementById('games').style.display = 'block';
				// Show loading spinner
				const grid = document.getElementById('gamesGrid');
				grid.innerHTML = '<div class="loading-container"><div class="spinner"></div><div class="loading-text">Loading all games...</div></div>';
				window.scrollTo(0, 0);
				// Small delay to let the spinner render before heavy work
				await new Promise(r => setTimeout(r, 50));
				// Update game count badge and hide Top 25 button for All Games view
				updateGameCountBadge();
				updateTop25Button();
				updateBatchLibretroButton();
				await renderGames();
			}

			async function goToAllGames(showMissingOnly) {
				// Set filter state
				filterMissingOnly = showMissingOnly;
				const btn = document.getElementById('filterMissingBtn');
				if (filterMissingOnly) {
					btn.classList.add('active');
				} else {
					btn.classList.remove('active');
				}
				// Go to all games view
				await selectAllGames();
			}

			function updateGameCountBadge() {
				let games = [];
				if (currentConsole === '__all__') {
					// Collect all games from all consoles
					const consoleFolders = Object.keys(consoles).filter(n => isConsole(n));
					for (const name of consoleFolders) {
						games = games.concat(consoles[name].games.map(g => ({...g, consoleName: name})));
					}
				} else if (currentConsole && consoles[currentConsole]) {
					games = consoles[currentConsole].games;
				} else {
					document.getElementById('gameCountBadge').style.display = 'none';
					return;
				}
				const total = games.length;
				const missing = games.filter(g => !g.hasImage).length;

				document.getElementById('totalGameCount').textContent = total;
				document.getElementById('gameCountBadge').style.display = 'inline';

				if (missing > 0) {
					document.getElementById('missingCount').textContent = missing;
					document.getElementById('missingArtCount').style.display = 'inline';
				} else {
					document.getElementById('missingArtCount').style.display = 'none';
				}
			}

			function showHome() {
				currentConsole = null;
				document.getElementById('floatingUpload').classList.remove('visible');
				// Show intro, hide games
				document.getElementById('intro').style.display = '';
				document.getElementById('games').style.display = 'none';
				document.getElementById('currentConsoleName').textContent = 'Select a console to view games';
				document.getElementById('currentConsoleIcon').style.display = 'none';
				document.getElementById('gamesGrid').innerHTML = '<p>Scan your drive to view games</p>';
				window.scrollTo(0, 0);
				// Show install button again if PWA install is available
				if (deferredPrompt) {
					document.getElementById('installPwaBtn').style.display = 'inline-flex';
				}
				// Close mobile menu if it's open
				const mobileMenu = document.getElementById('mobileMenuOverlay');
				if (mobileMenu && mobileMenu.classList.contains('active')) {
					toggleMobileMenu();
				}
			}

			async function renderGames() {
				if (!currentConsole) return;
				revokeObjectURLs(); // Clean up old image URLs before re-rendering
				const grid = document.getElementById('gamesGrid');
				let games = [];

				// Handle "All Games" view
				if (currentConsole === '__all__') {
					const consoleFolders = Object.keys(consoles).filter(n => isConsole(n));
					for (const name of consoleFolders) {
						games = games.concat(consoles[name].games.map(g => ({...g, consoleName: name})));
					}
				} else if (consoles[currentConsole]) {
					games = [...consoles[currentConsole].games];
				} else {
					return;
				}

				const search = document.getElementById('searchBox').value.toLowerCase();

				// Apply search filter
				let filtered = games.filter(g => g.baseName.toLowerCase().includes(search));

				// Apply missing art filter
				if (filterMissingOnly) {
					filtered = filtered.filter(g => !g.hasImage);
				}

				// Apply sorting (A-Z or Z-A)
				if (currentSort === 'za') {
					filtered.sort((a, b) => b.baseName.localeCompare(a.baseName));
				} else {
					filtered.sort((a, b) => a.baseName.localeCompare(b.baseName));
				}

				if (!filtered.length) {
					grid.innerHTML = filterMissingOnly
						? '<p>All games have box art! Nice work!</p>'
						: '<p>No games found</p>';
					return;
				}

				const cards = await Promise.all(filtered.map(async game => {
					let imgSrc = '';
					// Get the correct handle for this game (important for "All Games" view)
					const gameConsoleName = game.consoleName || currentConsole;
					const consoleData = consoles[gameConsoleName];
					const profile = deviceProfiles[currentDevice];

					// Determine correct image handle based on device type
					let imageHandle;
					if (profile.catalogueStructure) {
						// Trimui Brick / Mustard OS: Look in box folder
						if (consoleData?.boxHandle) {
							imageHandle = consoleData.boxHandle;
						} else if (consoleData?.handle) {
							// Try to get box folder if it exists now
							try {
								const boxDir = await consoleData.handle.getDirectoryHandle('box');
								consoleData.boxHandle = boxDir;
								imageHandle = boxDir;
							} catch {
								imageHandle = consoleData.handle;
							}
						}
					} else if (profile.isMinUI) {
						// MinUI: Look in .res folder
						if (consoleData?.resHandle) {
							imageHandle = consoleData.resHandle;
						} else if (consoleData?.handle) {
							// Try to get .res folder if it exists
							try {
								const resDir = await consoleData.handle.getDirectoryHandle('.res');
								consoleData.resHandle = resDir;
								imageHandle = resDir;
							} catch {
								imageHandle = consoleData.handle;
							}
						}
					} else if (profile.isNextUI) {
						// NextUI: Look in .media folder
						if (consoleData?.mediaHandle) {
							imageHandle = consoleData.mediaHandle;
						} else if (consoleData?.handle) {
							// Try to get .media folder if it exists
							try {
								const mediaDir = await consoleData.handle.getDirectoryHandle('.media');
								consoleData.mediaHandle = mediaDir;
								imageHandle = mediaDir;
							} catch {
								imageHandle = consoleData.handle;
							}
						}
					} else {
						// Other devices: Imgs folder or console folder
						imageHandle = consoleData?.imgsHandle || consoleData?.handle;
					}

					if (game.hasImage && game.imageExt) {
						// Try multiple locations for the image file:
						// 1. Standard image location (imageHandle)
						// 2. Same directory as the ROM (game.dirHandle) for games in subfolders
						const imageHandles = imageHandle ? [imageHandle, game.dirHandle] : [game.dirHandle];

						for (const imgHandle of imageHandles) {
							if (imgSrc || !imgHandle) continue;
							// For MinUI, try with full ROM filename first (e.g., "Pokemon Blue.gb.png")
							if (profile.isMinUI) {
								try {
									const f = await imgHandle.getFileHandle(game.name + game.imageExt);
									imgSrc = await createObjectURL(await f.getFile());
									break;
								} catch {}
							}
							// For all other devices (including NextUI), use basename
							if (!imgSrc) {
								try {
									const f = await imgHandle.getFileHandle(game.baseName + game.imageExt);
									imgSrc = await createObjectURL(await f.getFile());
									break;
								} catch {}
							}
						}
					}
					// For "All Games" view, include console name in the card
					const consoleLabel = currentConsole === '__all__' ? `<div class="game-console-label">${gameConsoleName}</div>` : '';
					// Show subfolder path in tooltip if game is in a subdirectory
					const gameTitle = game.relativePath && game.relativePath.includes('/')
						? `${game.baseName} (${game.relativePath.substring(0, game.relativePath.lastIndexOf('/'))})`
						: game.baseName;
					return `<div class="game-card" onclick="openGameModal('${game.name.replace(/'/g, "\\'")}', '${gameConsoleName.replace(/'/g, "\\'")}')" oncontextmenu="showContextMenu(event, '${game.name.replace(/'/g, "\\'")}', '${gameConsoleName.replace(/'/g, "\\'")}')">
						<div class="image-container">
							${imgSrc ? `<img src="${imgSrc}">` : '<span class="no-image">?</span>'}
							${!game.hasImage ? '<span class="missing-badge">No Image</span>' : ''}
						</div>
						<div class="game-name" title="${gameTitle}">${game.baseName}</div>
						${consoleLabel}
					</div>`;
				}));
				grid.innerHTML = cards.join('');
			}

			function filterGames() { renderGames(); }

			function toggleMissingFilter() {
				filterMissingOnly = !filterMissingOnly;
				const btn = document.getElementById('filterMissingBtn');
				if (filterMissingOnly) {
					btn.classList.add('active');
				} else {
					btn.classList.remove('active');
				}
				renderGames();
			}

			function toggleSort() {
				currentSort = currentSort === 'az' ? 'za' : 'az';
				document.getElementById('sortIcon').className = currentSort === 'az'
					? 'icon solid fa-sort-alpha-down'
					: 'icon solid fa-sort-alpha-up';
				document.getElementById('sortLabel').textContent = currentSort === 'az' ? 'A-Z' : 'Z-A';
				renderGames();
			}

			// Top 25 Games Feature
			function normalizeGameName(name) {
				// Normalize a game name for comparison: lowercase, remove punctuation, region codes, etc.
				return name
					.toLowerCase()
					.replace(/\([^)]*\)/g, '') // Remove (USA), (Europe), etc.
					.replace(/\[[^\]]*\]/g, '') // Remove [!], [T+Eng], etc.
					.replace(/[^a-z0-9]/g, '') // Remove non-alphanumeric
					.trim();
			}

			function checkGameOwned(topGameName, ownedGames) {
				const normalizedTop = normalizeGameName(topGameName);
				return ownedGames.some(game => {
					const normalizedOwned = normalizeGameName(game.baseName);
					// Check if either contains the other (fuzzy match)
					return normalizedOwned.includes(normalizedTop) ||
					       normalizedTop.includes(normalizedOwned) ||
					       // Also check for significant overlap
					       (normalizedTop.length > 5 && normalizedOwned.length > 5 &&
					        (normalizedTop.slice(0, 10) === normalizedOwned.slice(0, 10)));
				});
			}

			function getConsoleKey(consoleName) {
				// Map folder names to topGamesData keys
				// Includes MustardOS folder names (lowercase) for Trimui Brick support
				const mapping = {
					// Nintendo Handhelds
					'Game Boy': 'GB', 'GB': 'GB', 'gameboy': 'GB', 'Gameboy': 'GB', 'gb': 'GB',
					'Game Boy Color': 'GBC', 'GBC': 'GBC', 'gameboycolor': 'GBC', 'gbc': 'GBC',
					'Game Boy Advance': 'GBA', 'GBA': 'GBA', 'gameboyadvance': 'GBA', 'gba': 'GBA',
					'NDS': 'NDS', 'Nintendo DS': 'NDS', 'nds': 'NDS', 'DS': 'NDS', 'ds': 'NDS',
					// Nintendo Home
					'NES': 'NES', 'FC': 'NES', 'Famicom': 'NES', 'famicom': 'NES', 'nes': 'NES', 'fds': 'NES', 'fc': 'NES',
					'SNES': 'SNES', 'SFC': 'SNES', 'Super Famicom': 'SNES', 'superfamicom': 'SNES', 'snes': 'SNES', 'sfc': 'SNES',
					'N64': 'N64', 'Nintendo 64': 'N64', 'nintendo64': 'N64', 'n64': 'N64',
					'Virtual Boy': 'Virtual Boy', 'VB': 'Virtual Boy', 'virtualboy': 'Virtual Boy', 'vb': 'Virtual Boy',
					// Sega
					'Genesis': 'Genesis', 'MD': 'Genesis', 'Sega Genesis': 'Genesis', 'Mega Drive': 'Genesis', 'megadrive': 'Genesis', 'segamd': 'Genesis', 'genesis': 'Genesis', 'md': 'Genesis',
					'Game Gear': 'Game Gear', 'GG': 'Game Gear', 'gamegear': 'Game Gear', 'gg': 'Game Gear',
					'Master System': 'Master System', 'MS': 'Master System', 'Sega Master System': 'Master System', 'SMS': 'Master System', 'mastersystem': 'Master System', 'sms': 'Master System',
					'Sega CD': 'Sega CD', 'segacd': 'Sega CD', 'mdcd': 'Sega CD', 'Mega CD': 'Sega CD', 'segamdcd': 'Sega CD',
					'Sega 32X': 'Sega 32X', 'sega32x': 'Sega 32X', '32X': 'Sega 32X',
					'Saturn': 'Saturn', 'saturn': 'Saturn', 'Sega Saturn': 'Saturn',
					'Dreamcast': 'Dreamcast', 'dreamcast': 'Dreamcast', 'DC': 'Dreamcast', 'dc': 'Dreamcast',
					// Sony
					'PS1': 'PS1', 'PSX': 'PS1', 'PlayStation': 'PS1', 'PS': 'PS1', 'playstation': 'PS1', 'ps1': 'PS1', 'psx': 'PS1', 'ps': 'PS1',
					'PSP': 'PSP', 'psp': 'PSP',
					// NEC
					'PCE': 'PCE', 'PC Engine': 'PCE', 'TurboGrafx-16': 'PCE', 'TurboGrafx': 'PCE', 'pcengine': 'PCE', 'turbografx': 'PCE', 'pce': 'PCE',
					// SNK
					'Neo Geo': 'Neo Geo', 'NEOGEO': 'Neo Geo', 'neogeo': 'Neo Geo', 'NeoGeo': 'Neo Geo',
					'Neo Geo Pocket': 'Neo Geo Pocket', 'NGP': 'Neo Geo Pocket', 'NGPC': 'Neo Geo Pocket', 'neogeopocket': 'Neo Geo Pocket', 'ngp': 'Neo Geo Pocket', 'ngpc': 'Neo Geo Pocket',
					// Atari
					'Atari 2600': 'Atari 2600', 'atari2600': 'Atari 2600', 'ATARI': 'Atari 2600', 'Atari': 'Atari 2600',
					'Atari 5200': 'Atari 5200', 'atari5200': 'Atari 5200', 'a5200': 'Atari 5200',
					'Atari 7800': 'Atari 7800', 'atari7800': 'Atari 7800', 'a7800': 'Atari 7800',
					'Atari Lynx': 'Atari Lynx', 'LYNX': 'Atari Lynx', 'Lynx': 'Atari Lynx', 'atarilynx': 'Atari Lynx', 'lynx': 'Atari Lynx',
					// Bandai
					'WonderSwan': 'WonderSwan', 'WS': 'WonderSwan', 'wonderswan': 'WonderSwan', 'ws': 'WonderSwan', 'wsc': 'WonderSwan',
					// Other Consoles
					'Coleco': 'Coleco', 'coleco': 'Coleco', 'ColecoVision': 'Coleco', 'colecovision': 'Coleco',
					'Intellivision': 'Intellivision', 'intellivision': 'Intellivision', 'INTV': 'Intellivision', 'intv': 'Intellivision',
					'Vectrex': 'Vectrex', 'vectrex': 'Vectrex',
					'3DO': '3DO', '3do': '3DO',
					// Computers
					'Amiga': 'Amiga', 'amiga': 'Amiga',
					'Commodore 64': 'Commodore 64', 'C64': 'Commodore 64', 'c64': 'Commodore 64'
				};
				return mapping[consoleName] || consoleName;
			}

			function openTop25Modal() {
				if (!currentConsole || currentConsole === '__all__') return;

				const consoleKey = getConsoleKey(currentConsole);
				const topGames = topGamesData[consoleKey];

				if (!topGames) {
					alert('Top 25 list not available for this console yet.');
					return;
				}

				const ownedGames = consoles[currentConsole]?.games || [];
				const list = document.getElementById('top25List');
				let owned = 0, missing = 0;

				document.getElementById('top25ConsoleName').textContent = currentConsole + ' Games';

				const html = topGames.map((game, idx) => {
					const isOwned = checkGameOwned(game, ownedGames);
					if (isOwned) owned++; else missing++;
					return `<div class="top25-item ${isOwned ? 'owned' : 'missing'}">
						<span class="top25-rank">#${idx + 1}</span>
						<span class="top25-icon ${isOwned ? 'owned' : 'missing'}">
							<span class="icon solid fa-${isOwned ? 'check' : 'times'}"></span>
						</span>
						<span class="top25-name">${game}</span>
					</div>`;
				}).join('');

				list.innerHTML = html;
				document.getElementById('top25Owned').textContent = owned;
				document.getElementById('top25Missing').textContent = missing;
				document.getElementById('top25Modal').classList.add('active');

				// Setup drag and drop
				setupTop25DragDrop();
			}

			function setupTop25DragDrop() {
				const dropZone = document.getElementById('top25DropZone');

				dropZone.ondragover = (e) => {
					e.preventDefault();
					dropZone.classList.add('dragover');
				};
				dropZone.ondragleave = () => {
					dropZone.classList.remove('dragover');
				};
				dropZone.ondrop = async (e) => {
					e.preventDefault();
					dropZone.classList.remove('dragover');
					const files = Array.from(e.dataTransfer.files);
					await uploadTop25Files(files);
				};
			}

			async function handleTop25Upload(event) {
				const files = Array.from(event.target.files);
				await uploadTop25Files(files);
				event.target.value = '';
			}

			async function uploadTop25Files(files) {
				if (!files.length || !currentConsole || !consoles[currentConsole]) return;

				const consoleData = consoles[currentConsole];
				const romExts = ['.gb', '.gbc', '.gba', '.nes', '.sfc', '.smc', '.md', '.gen', '.gg', '.sms', '.bin', '.zip', '.7z'];

				let uploaded = 0;
				for (const file of files) {
					const ext = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();
					if (!romExts.includes(ext)) continue;

					try {
						// Clean filename
						let cleanName = file.name
							.replace(/\([^)]*\)/g, '')
							.replace(/\[[^\]]*\]/g, '')
							.replace(/\s+/g, ' ')
							.trim();
						// Ensure extension
						if (!cleanName.toLowerCase().endsWith(ext)) {
							cleanName = cleanName.substring(0, cleanName.lastIndexOf('.')) + ext;
						}

						const fh = await consoleData.handle.getFileHandle(cleanName, { create: true });
						const w = await fh.createWritable();
						await w.write(file);
						await w.close();
						uploaded++;
					} catch (e) {
						console.error('Upload error:', e);
					}
				}

				if (uploaded > 0) {
					// Refresh the entire directory to pick up new files
					await scanExistingDirectory();
					// Refresh the modal
					openTop25Modal();
					// Refresh main grid
					await renderGames();
				}
			}

			function updateTop25Button() {
				const btn = document.getElementById('top25Btn');
				if (!currentConsole || currentConsole === '__all__') {
					btn.style.display = 'none';
					return;
				}
				const consoleKey = getConsoleKey(currentConsole);
				btn.style.display = topGamesData[consoleKey] ? '' : 'none';
			}
			
			function updateBatchLibretroButton() {
				const btn = document.getElementById('batchLibretroBtn');
				if (!currentConsole || currentConsole === '__all__' || !consoles[currentConsole]) {
					btn.style.display = 'none';
					return;
				}
				
				// Show button only if there are games without art
				const gamesWithoutArt = consoles[currentConsole].games.filter(game => !game.hasImage);
				btn.style.display = gamesWithoutArt.length > 0 ? '' : 'none';
			}

			let gameConsole = null; // Track which console the current game belongs to

			function openGameModal(gameName, consoleName) {
				currentGame = gameName;
				gameConsole = consoleName || currentConsole;
				const baseName = gameName.substring(0, gameName.lastIndexOf('.'));
				const modalTitle = document.getElementById('modalGameName');
				modalTitle.textContent = baseName;
				document.getElementById('gameTitleTooltip').textContent = baseName;
				document.getElementById('imageUrl').value = '';
				document.getElementById('imageStatus').className = 'status-msg';
				document.getElementById('imageStatus').style.display = 'none';
				loadGameImage(baseName);
				updateNextGameButton();
				// Fetch GameFAQs info (async, non-blocking)
				fetchGameFAQsInfo(baseName, gameConsole);
				// Show/hide saves button and local image rows based on device
				// Saves supported for RG Nano and Onion OS devices (Miyoo Mini, Miyoo Flip)
				const savesBtn = document.getElementById('savesButtonRow');
				const noSavesRow = document.getElementById('noSavesButtonRow');
				const supportsSaves = currentDevice === 'rgnano' || isOnionOS(currentDevice);
				if (supportsSaves) {
					savesBtn.style.display = 'block';
					noSavesRow.style.display = 'none';
				} else {
					savesBtn.style.display = 'none';
					noSavesRow.style.display = 'grid';
				}
				document.getElementById('gameModal').classList.add('active');
			}

			async function loadGameImage(baseName) {
				const preview = document.getElementById('modalImagePreview');
				const targetConsole = gameConsole || currentConsole;
				if (!targetConsole || !consoles[targetConsole]) {
					preview.innerHTML = '<span class="no-image">?</span>'; return;
				}

				const profile = deviceProfiles[currentDevice];
				let imageHandle;

				if (profile.catalogueStructure) {
					// Trimui Brick / Mustard OS: Look in box folder
					if (consoles[targetConsole].boxHandle) {
						imageHandle = consoles[targetConsole].boxHandle;
					} else {
						// Try to get box folder if it exists now (may have been created after initial scan)
						try {
							const boxDir = await consoles[targetConsole].handle.getDirectoryHandle('box');
							consoles[targetConsole].boxHandle = boxDir;
							imageHandle = boxDir;
						} catch {
							// Box folder doesn't exist, fallback to system folder
							imageHandle = consoles[targetConsole].handle;
						}
					}
				} else if (profile.isMinUI) {
					// MinUI: Look in .res folder
					if (consoles[targetConsole].resHandle) {
						imageHandle = consoles[targetConsole].resHandle;
					} else {
						// Try to get .res folder if it exists now
						try {
							const resDir = await consoles[targetConsole].handle.getDirectoryHandle('.res');
							consoles[targetConsole].resHandle = resDir;
							imageHandle = resDir;
						} catch {
							// .res folder doesn't exist, fallback to console folder
							imageHandle = consoles[targetConsole].handle;
						}
					}
				} else if (profile.isNextUI) {
					// NextUI: Look in .media folder
					if (consoles[targetConsole].mediaHandle) {
						imageHandle = consoles[targetConsole].mediaHandle;
					} else {
						// Try to get .media folder if it exists now
						try {
							const mediaDir = await consoles[targetConsole].handle.getDirectoryHandle('.media');
							consoles[targetConsole].mediaHandle = mediaDir;
							imageHandle = mediaDir;
						} catch {
							// .media folder doesn't exist, fallback to console folder
							imageHandle = consoles[targetConsole].handle;
						}
					}
				} else {
					// Other devices: Imgs folder or console folder
					imageHandle = consoles[targetConsole].imgsHandle || consoles[targetConsole].handle;
				}

				// Find the game object to get its directory handle
				const game = consoles[targetConsole].games.find(g => g.name === currentGame);
				const gameDir = game && game.dirHandle ? game.dirHandle : null;

				// Try multiple locations: standard image location and game's directory
				const imageHandles = gameDir ? [imageHandle, gameDir] : [imageHandle];
				let imageLoaded = false;

				for (const imgHandle of imageHandles) {
					if (imageLoaded || !imgHandle) continue;

					// For MinUI, try with ROM extension first (e.g., "Pokemon Red.gb.png")
					if (profile.isMinUI) {
						try {
							const f = await imgHandle.getFileHandle(currentGame + '.png');
							preview.innerHTML = `<img src="${await createObjectURL(await f.getFile())}">`;
							imageLoaded = true;
							break;
						} catch {
							try {
								const f = await imgHandle.getFileHandle(currentGame + '.jpg');
								preview.innerHTML = `<img src="${await createObjectURL(await f.getFile())}">`;
								imageLoaded = true;
								break;
							} catch {}
						}
					}

					// For all devices (including NextUI), try without ROM extension
					if (!imageLoaded) {
						try {
							const f = await imgHandle.getFileHandle(baseName + '.png');
							preview.innerHTML = `<img src="${await createObjectURL(await f.getFile())}">`;
							imageLoaded = true;
							break;
						} catch {
							try {
								const f = await imgHandle.getFileHandle(baseName + '.jpg');
								preview.innerHTML = `<img src="${await createObjectURL(await f.getFile())}">`;
								imageLoaded = true;
								break;
							} catch {}
						}
					}
				}

				if (!imageLoaded) {
					preview.innerHTML = '<span class="no-image">?</span>';
				}
			}

			let selectedPickerUrl = null;

			function openImagePicker() {
				const baseName = currentGame ? currentGame.substring(0, currentGame.lastIndexOf('.')) : '';
				document.getElementById('pickerSearchQuery').value = baseName;
				document.getElementById('pickerGrid').innerHTML = '<div class="no-results">Enter a game name and click Search</div>';
				document.getElementById('pickerSelectBtn').disabled = true;
				selectedPickerUrl = null;
				document.getElementById('imagePicker').classList.add('active');
				// Auto-search if we have a name
				if (baseName) searchImagesInPicker();
			}

			function closeImagePicker() {
				document.getElementById('imagePicker').classList.remove('active');
			}

			// Search RDB database for game names
			async function searchRDBDatabase(q) {
				const images = [];
				
				try {
					// Fetch RDB game name database
					const response = await fetch('rdb_gamename.json');
					if (!response.ok) {
						throw new Error(`Failed to fetch RDB database: ${response.status}`);
					}
					
					const rdbData = await response.json();
					const queryLower = q.toLowerCase();
					const matchedKeys = [];
					
					// Find matching keys (fuzzy matching)
					for (const key in rdbData) {
						if (key.toLowerCase().includes(queryLower)) {
							matchedKeys.push(key);
						}
						
						// If we have more than 50 matches, stop searching
						if (matchedKeys.length > 50) {
							break;
						}
					}
					
					// If more than 50 matches, return an error message object
					if (matchedKeys.length > 50) {
						return {
							error: 'æœç´¢èŒƒå›´è¿‡å¤§ï¼Œè¯·ç¼©å°æœç´¢èŒƒå›´',
							results: []
						};
					}
					
					// Create image URLs for matched keys using Libretro URL format
					for (const key of matchedKeys) {
						const gameInfo = rdbData[key];
						if (gameInfo && gameInfo.system) {
							// Keep system name as is, but encode spaces as %20 for URL compatibility
							const system = gameInfo.system.replace(/ /g, '%20');
							
							// Create Libretro-style URL
							const name = key; // Use full key as name
							const imageUrl = `https://thumbnails.libretro.com/${system}/Named_Boxarts/${encodeURIComponent(name)}.png`;
							
							images.push({
								thumb: imageUrl,
								full: imageUrl,
								source: 'RDB',
								name: name
							});
						}
					}
					
				} catch (error) {
					console.error('Error searching RDB database:', error);
				}
				
				return images;
			}
			


			async function searchImagesInPicker() {
				const q = document.getElementById('pickerSearchQuery').value.trim();
				if (!q) return;

				const grid = document.getElementById('pickerGrid');
				grid.innerHTML = '<div class="loading">Searching for covers...</div>';
				document.getElementById('pickerSelectBtn').disabled = true;
				selectedPickerUrl = null;
				
				// Get selected search source
				const searchSource = document.getElementById('pickerSearchSource').value;

				try {
					const images = [];
					const parser = new DOMParser();
					const consoleName = gameConsole || currentConsole;

					// Define which sources to search based on selection
					const searchPromises = [];
					
					if (searchSource === 'all' || searchSource === 'rdb') {
						searchPromises.push(
							searchRDBDatabase(q).then(results => {
								// Handle error case when too many results are found
								if (results && results.error) {
									return { 
										source: 'rdb', 
										value: results.results,
										error: results.error
									};
								}
								return { source: 'rdb', value: results };
							})
						);
					}
					if (searchSource === 'all' || searchSource === 'gamesdb') {
						searchPromises.push(
							searchTheGamesDB(q, parser).then(results => ({ source: 'gamesdb', value: results }))
						);
					}
					if (searchSource === 'all' || searchSource === 'gamefaqs') {
						searchPromises.push(
							searchGameFAQs(q, parser, consoleName).then(results => ({ source: 'gamefaqs', value: results }))
						);
					}
					if (searchSource === 'all' || searchSource === 'coverproject') {
						searchPromises.push(
							searchTheCoverProject(q, parser).then(results => ({ source: 'coverproject', value: results }))
						);
					}

					// Execute all search promises in parallel
					const searchResults = await Promise.allSettled(searchPromises);
					
					// Combine results from all sources
					let errorMessage = null;
					for (const result of searchResults) {
						if (result.status === 'fulfilled' && result.value) {
							// Check for error message
							if (result.value.error) {
								errorMessage = result.value.error;
							}
							// Add images if they exist
							if (result.value.value && Array.isArray(result.value.value)) {
								images.push(...result.value.value);
							}
						}
					}

					// If no images found and searching all sources, try fallback search methods
					if (images.length === 0 && searchSource === 'all') {
						try {
							// Try a simple Google Images search as ultimate fallback
							const fallbackUrl = `https://www.google.com/search?tbm=isch&q=${encodeURIComponent(q + ' box art cover')}`;
							
							// Try direct fetch first
							let response = null;
							try {
								response = await fetch(fallbackUrl, {
									method: 'GET',
									mode: 'cors',
									credentials: 'omit',
									headers: {
										'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
									}
								});
							} catch (directError) {
								console.log('Direct Google Images fetch failed:', directError);
								// Try alternative proxy as last resort
								try {
									response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(fallbackUrl)}`);
								} catch (proxyError) {
									console.log('Google Images proxy also failed:', proxyError);
								}
							}
							
							if (response && response.ok) {
								let html;
								if (response.url && response.url.includes('allorigins')) {
									// Handle JSON response from allorigins
									const result = await response.json();
									html = result.contents;
								} else {
									// Handle direct response
									html = await response.text();
								}
								
								const doc = new DOMParser().parseFromString(html, 'text/html');
								
								// Extract image URLs from Google Images results (simple approach)
								doc.querySelectorAll('img').forEach(img => {
									const src = img.getAttribute('src');
									if (src && (src.startsWith('http') || src.startsWith('//')) && !src.includes('gstatic.com')) {
										const fullSrc = src.startsWith('//') ? 'https:' + src : src;
										images.push({ thumb: fullSrc, full: fullSrc });
									}
								});
							}
						} catch (fallbackError) {
							console.log('Fallback search failed:', fallbackError);
						}
					}

					if (images.length === 0) {
						if (errorMessage) {
							grid.innerHTML = `<div class="no-results">${errorMessage}</div>`;
						} else {
							grid.innerHTML = '<div class="no-results">No images found. Try Google Images instead.</div>';
						}
						return;
					}

					// Remove duplicates
					const uniqueImages = images.filter((img, idx, arr) =>
						arr.findIndex(i => i.full === img.full) === idx
					);

					grid.innerHTML = uniqueImages.slice(0, 30).map(img => {
						const source = img.source || 'unknown';
						const title = img.source ? `Source: ${img.source}` : 'Click to select, double-click to use';
						return `<img src="${img.thumb}" data-url="${img.full}" onclick="selectPickerImage(this)" ondblclick="selectPickerImage(this); confirmImageSelection();" title="${title}" onerror="this.style.display='none'">`;
					}).join('');
				} catch (e) {
					grid.innerHTML = '<div class="no-results">Search unavailable. Try Google Images instead.</div>';
				}
			}

			async function searchTheGamesDB(q, parser) {
				const images = [];
				
				try {
					const searchUrl = `https://thegamesdb.net/search.php?name=${encodeURIComponent(q)}`;
					
					// Try direct fetch first with relaxed headers
					let response = null;
					try {
						response = await fetch(searchUrl, {
							method: 'GET',
							mode: 'cors',
							credentials: 'omit',
							headers: {
								'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
							}
						});
					} catch (directError) {
						console.log('Direct fetch failed, trying proxy:', directError);
						// If direct fetch fails, try alternative proxy
						try {
							response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(searchUrl)}`);
						} catch (proxyError) {
							console.log('Proxy fetch also failed:', proxyError);
						}
					}
					
					if (!response || !response.ok) return images;

					let html;
					if (response.url && response.url.includes('allorigins')) {
						// Handle JSON response from allorigins
						const result = await response.json();
						html = result.contents;
					} else {
						// Handle direct response
						html = await response.text();
					}
					
					const doc = parser.parseFromString(html, 'text/html');

					// Find all game images in search results
					const gameImgs = doc.querySelectorAll('img[src*="cdn.thegamesdb.net"]');
					gameImgs.forEach(img => {
						const thumbUrl = img.getAttribute('src');
						if (thumbUrl && thumbUrl.includes('/boxart/')) {
							const fullUrl = thumbUrl.replace('/thumb/', '/original/');
							images.push({ thumb: thumbUrl, full: fullUrl });
						}
					});

					// Also check for game detail links to get more images
					const gameLinks = doc.querySelectorAll('a[href*="game.php?id="]');
					const uniqueIds = [...new Set(Array.from(gameLinks).map(a => {
						const match = a.getAttribute('href').match(/id=(\d+)/);
						return match ? match[1] : null;
					}).filter(Boolean))];

					// Fetch additional images from first few game pages
					for (const gameId of uniqueIds.slice(0, 3)) {
						try {
							const gameUrl = `https://thegamesdb.net/game.php?id=${gameId}`;
							
							// Try direct fetch for game page
							let gameResponse = null;
							try {
								gameResponse = await fetch(gameUrl, {
									method: 'GET',
									mode: 'cors',
									credentials: 'omit',
									headers: {
										'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
									}
								});
							} catch (directError) {
								console.log('Direct game page fetch failed, trying proxy:', directError);
								// If direct fetch fails, try alternative proxy
								try {
									gameResponse = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(gameUrl)}`);
								} catch (proxyError) {
									console.log('Game page proxy fetch also failed:', proxyError);
								}
							}
							
							if (gameResponse && gameResponse.ok) {
								let gameHtml;
								if (gameResponse.url && gameResponse.url.includes('allorigins')) {
									// Handle JSON response from allorigins
									const result = await gameResponse.json();
									gameHtml = result.contents;
								} else {
									// Handle direct response
									gameHtml = await gameResponse.text();
								}
								
								const gameDoc = parser.parseFromString(gameHtml, 'text/html');

								const boxartImgs = gameDoc.querySelectorAll('img[src*="cdn.thegamesdb.net"]');
								boxartImgs.forEach(img => {
									const src = img.getAttribute('src');
									if (src && (src.includes('/boxart/') || src.includes('/screenshot'))) {
										const fullUrl = src.replace('/thumb/', '/original/');
										if (!images.find(i => i.full === fullUrl)) {
											images.push({ thumb: src, full: fullUrl });
										}
									}
								});
							}
						} catch (e) { /* Ignore errors */ }
						if (images.length >= 15) break;
					}
				} catch (e) {
					console.log('TheGamesDB search error:', e);
				}
				return images;
			}

			async function searchTheCoverProject(q, parser) {
				const images = [];
				
				try {
					// Attempt to search The Cover Project with multiple approaches
					const searchUrl = `https://thecoverproject.net/view.php?search=${encodeURIComponent(q)}`;
					
					// Try direct fetch first with relaxed headers
					let response = null;
					try {
						response = await fetch(searchUrl, {
							method: 'GET',
							mode: 'cors',
							credentials: 'omit',
							headers: {
								'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
							}
						});
					} catch (directError) {
						console.log('Direct The Cover Project fetch failed, trying proxy:', directError);
						// If direct fetch fails, try alternative proxy
						try {
							response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(searchUrl)}`);
						} catch (proxyError) {
							console.log('The Cover Project proxy fetch also failed:', proxyError);
						}
					}
					
					if (!response || !response.ok) return images;
					
					let html;
					if (response.url && response.url.includes('allorigins')) {
						// Handle JSON response from allorigins
						const result = await response.json();
						html = result.contents;
					} else {
						// Handle direct response
						html = await response.text();
					}
					
					const doc = parser.parseFromString(html, 'text/html');
					
					// Find cover images
					const coverImages = doc.querySelectorAll('img[src*="thecoverproject.net"]');
					coverImages.forEach(img => {
						const src = img.getAttribute('src');
						if (src && src.includes('/cover/')) {
							// Try to get full size image
							const fullUrl = src.replace('_thumb', '').replace('_small', '');
							images.push({ thumb: src, full: fullUrl });
						}
					});
				} catch (e) {
					console.log('The Cover Project search error:', e);
				}
				
				return images;
			}

			// GameFAQs platform code mapping
			const gameFaqsPlatformMap = {
				// Nintendo Handhelds
				'GB': 'gameboy', 'GBC': 'gbc', 'GBA': 'gba', 'NDS': 'ds', 'DS': 'ds',
				// Nintendo Home
				'NES': 'nes', 'FC': 'nes', 'SNES': 'snes', 'SFC': 'snes', 'N64': 'n64', 'Virtual Boy': 'virtualboy',
				// Sega
				'Genesis': 'genesis', 'MD': 'genesis', 'Game Gear': 'gamegear', 'GG': 'gamegear',
				'Master System': 'sms', 'SMS': 'sms', 'MS': 'sms',
				'Sega CD': 'segacd', 'Sega 32X': 'sega32x', '32X': 'sega32x',
				'Saturn': 'saturn', 'Dreamcast': 'dreamcast', 'DC': 'dreamcast',
				// Sony
				'PS1': 'ps', 'PSX': 'ps', 'PlayStation': 'ps', 'PSP': 'psp',
				// NEC
				'PCE': 'tg16', 'PC Engine': 'tg16', 'TurboGrafx-16': 'tg16', 'TurboGrafx': 'tg16',
				// SNK
				'Neo Geo': 'neo', 'NEOGEO': 'neo', 'Neo Geo Pocket': 'ngpc', 'NGP': 'ngpc', 'NGPC': 'ngpc',
				// Atari
				'Atari 2600': 'atari2600', 'Atari 5200': 'atari5200', 'Atari 7800': 'atari7800', 'Atari Lynx': 'lynx',
				// Bandai
				'WonderSwan': 'wonderswan', 'WS': 'wonderswan',
				// Other
				'Coleco': 'colecovision', 'ColecoVision': 'colecovision',
				'Intellivision': 'intellivision', '3DO': '3do',
				// Arcade
				'Arcade': 'arcade', 'MAME': 'arcade', 'CPS1': 'arcade', 'CPS2': 'arcade', 'CPS3': 'arcade'
			};

			async function searchGameFAQs(q, parser, consoleName) {
				const images = [];

				// Get platform code for GameFAQs
				const consoleKey = getConsoleKey(consoleName);
				const platformCode = gameFaqsPlatformMap[consoleKey];

				// Related platforms (GB and GBC games are often interchangeable)
				const relatedPlatforms = {
					'gameboy': ['gameboy', 'gbc'],
					'gbc': ['gbc', 'gameboy'],
					'nes': ['nes'],
					'snes': ['snes'],
					'gba': ['gba'],
					'genesis': ['genesis'],
					'n64': ['n64'],
					'ps': ['ps'],
					'ds': ['ds']
				};
				const allowedPlatforms = platformCode ? (relatedPlatforms[platformCode] || [platformCode]) : null;

				try {
					// Use GameFAQs JSON search API
					const searchUrl = `https://gamefaqs.gamespot.com/ajax/home_game_search?term=${encodeURIComponent(q)}`;
					
					// Try direct fetch first with relaxed headers
					let response = null;
					try {
						response = await fetch(searchUrl, {
							method: 'GET',
							mode: 'cors',
							credentials: 'omit',
							headers: {
								'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
							}
						});
					} catch (directError) {
						console.log('Direct GameFAQs fetch failed, trying proxy:', directError);
						// If direct fetch fails, try alternative proxy
						try {
							response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(searchUrl)}`);
						} catch (proxyError) {
							console.log('GameFAQs proxy fetch also failed:', proxyError);
						}
					}
					
					if (!response || !response.ok) return images;
					
					let data;
					if (response.url && response.url.includes('allorigins')) {
						// Handle JSON response from allorigins
						const result = await response.json();
						data = JSON.parse(result.contents);
					} else {
						// Handle direct response
						data = await response.json();
					}
					
					if (!Array.isArray(data)) return images;

					// Filter results by platform and collect game URLs
					// Prioritize games whose name closely matches the search query
					const gameMatches = [];
					const searchLower = q.toLowerCase().replace(/[^a-z0-9]/g, '');

					for (const game of data) {
						if (!game.url || !game.platform_url) continue;

						// Check if platform matches
						const platformMatch = allowedPlatforms ? allowedPlatforms.includes(game.platform_url) : true;
						if (!platformMatch) continue;

						// Score by name similarity - exact match gets highest priority
						const gameName = (game.game_name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
						let score = 0;
						if (gameName === searchLower) score = 100; // Exact match
						else if (gameName.includes(searchLower)) score = 50; // Contains search
						else if (searchLower.includes(gameName)) score = 25; // Search contains game name

						// Boost exact platform match
						if (game.platform_url === platformCode) score += 10;

						gameMatches.push({ url: game.url, name: game.game_name, score });
					}

					// Sort by score descending
					gameMatches.sort((a, b) => b.score - a.score);
					const gameUrls = gameMatches.map(g => g.url);

					// Helper to convert relative URLs to absolute
					const toAbsoluteUrl = (src) => {
						if (src.startsWith('//')) return 'https:' + src;
						if (src.startsWith('/')) return 'https://gamefaqs.gamespot.com' + src;
						if (!src.startsWith('http')) return 'https://gamefaqs.gamespot.com/' + src;
						return src;
					};

					// Fetch box art from /boxes page for the best match
					const uniqueUrls = [...new Set(gameUrls)].slice(0, 1);
					for (const gameUrl of uniqueUrls) {
						try {
							// Go directly to the /boxes page for box art
							const boxesPageUrl = `https://gamefaqs.gamespot.com${gameUrl}/boxes`;
							
							// Try direct fetch first with relaxed headers
							let boxesResponse = null;
							try {
								boxesResponse = await fetch(boxesPageUrl, {
									method: 'GET',
									mode: 'cors',
									credentials: 'omit',
									headers: {
										'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
									}
								});
							} catch (directError) {
								console.log('Direct GameFAQs boxes page fetch failed, trying proxy:', directError);
								// If direct fetch fails, try alternative proxy
								try {
									boxesResponse = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(boxesPageUrl)}`);
								} catch (proxyError) {
									console.log('GameFAQs boxes page proxy fetch also failed:', proxyError);
								}
							}
							
							if (boxesResponse && boxesResponse.ok) {
								let boxesHtml;
								if (boxesResponse.url && boxesResponse.url.includes('allorigins')) {
									// Handle JSON response from allorigins
									const result = await boxesResponse.json();
									boxesHtml = result.contents;
								} else {
									// Handle direct response
									boxesHtml = await boxesResponse.text();
								}
								
								const boxesDoc = parser.parseFromString(boxesHtml, 'text/html');

								// Find all box art images
								boxesDoc.querySelectorAll('img[src*="/a/box/"]').forEach(img => {
									const src = img.getAttribute('src');
									if (src) {
										const thumbUrl = toAbsoluteUrl(src);
										const imgFullUrl = thumbUrl.replace('_thumb.jpg', '_front.jpg');
										if (!images.find(i => i.full === imgFullUrl)) {
											images.push({ thumb: thumbUrl, full: imgFullUrl });
										}
									}
								});
							}
						} catch (e) { /* Ignore errors */ }

						if (images.length >= 10) break;
					}
				} catch (e) {
					console.log('GameFAQs search error:', e);
				}

				return images;
			}

			// Fetch game info (rating, difficulty, length) from GameFAQs
			async function fetchGameFAQsInfo(gameName, consoleName) {
				const infoDiv = document.getElementById('gameFaqsInfo');
				const ratingEl = document.getElementById('gfRating');
				const difficultyEl = document.getElementById('gfDifficulty');
				const lengthEl = document.getElementById('gfLength');
				const ratingTooltip = document.getElementById('gfRatingTooltip');
				const difficultyTooltip = document.getElementById('gfDifficultyTooltip');
				const lengthTooltip = document.getElementById('gfLengthTooltip');

				// Reset and hide while loading
				infoDiv.style.display = 'none';
				ratingEl.innerHTML = '<span class="icon solid fa-star"></span> --';
				difficultyEl.innerHTML = '<span class="icon solid fa-heartbeat"></span> --';
				lengthEl.innerHTML = '<span class="icon solid fa-clock"></span> --';
				ratingTooltip.innerHTML = '';
				difficultyTooltip.innerHTML = '';
				lengthTooltip.innerHTML = '';

				try {
					// Get platform code
					const consoleKey = getConsoleKey(consoleName);
					const platformCode = gameFaqsPlatformMap[consoleKey];
					const relatedPlatforms = {
						'gameboy': ['gameboy', 'gbc'],
						'gbc': ['gbc', 'gameboy'],
						'nes': ['nes'],
						'snes': ['snes'],
						'gba': ['gba'],
						'genesis': ['genesis'],
						'n64': ['n64'],
						'ps': ['ps'],
						'ds': ['ds']
					};
					const allowedPlatforms = platformCode ? (relatedPlatforms[platformCode] || [platformCode]) : null;

					// Search for the game
					const searchUrl = `https://gamefaqs.gamespot.com/ajax/home_game_search?term=${encodeURIComponent(gameName)}`;
					
					// Try direct fetch first with relaxed headers
					let response = null;
					try {
						response = await fetch(searchUrl, {
							method: 'GET',
							mode: 'cors',
							credentials: 'omit',
							headers: {
								'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
							}
						});
					} catch (directError) {
						console.log('Direct GameFAQs info fetch failed, trying proxy:', directError);
						// If direct fetch fails, try alternative proxy
						try {
							response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(searchUrl)}`);
						} catch (proxyError) {
							console.log('GameFAQs info proxy fetch also failed:', proxyError);
							return; // If both fail, exit early
						}
					}
					
					if (!response || !response.ok) return;
					
					let data;
					if (response.url && response.url.includes('allorigins')) {
						// Handle JSON response from allorigins
						const result = await response.json();
						data = JSON.parse(result.contents);
					} else {
						// Handle direct response
						data = await response.json();
					}
					if (!Array.isArray(data)) return;

					// Find best matching game
					const searchLower = gameName.toLowerCase().replace(/[^a-z0-9]/g, '');
					let bestMatch = null;
					let bestScore = 0;

					for (const game of data) {
						if (!game.url || !game.platform_url) continue;
						const platformMatch = allowedPlatforms ? allowedPlatforms.includes(game.platform_url) : true;
						if (!platformMatch) continue;

						const gameNameLower = (game.game_name || '').toLowerCase().replace(/[^a-z0-9]/g, '');
						let score = 0;
						if (gameNameLower === searchLower) score = 100;
						else if (gameNameLower.includes(searchLower)) score = 50;
						else if (searchLower.includes(gameNameLower)) score = 25;
						if (game.platform_url === platformCode) score += 10;

						if (score > bestScore) {
							bestScore = score;
							bestMatch = game;
						}
					}

					if (!bestMatch) return;

					// Fetch the game page
					const gamePageUrl = `https://gamefaqs.gamespot.com${bestMatch.url}`;
					
					// Try direct fetch first with relaxed headers
					let gameResponse = null;
					try {
						gameResponse = await fetch(gamePageUrl, {
							method: 'GET',
							mode: 'cors',
							credentials: 'omit',
							headers: {
								'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
							}
						});
					} catch (directError) {
						console.log('Direct GameFAQs game page fetch failed, trying proxy:', directError);
						// If direct fetch fails, try alternative proxy
						try {
							gameResponse = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(gamePageUrl)}`);
						} catch (proxyError) {
							console.log('GameFAQs game page proxy fetch also failed:', proxyError);
							return; // If both fail, exit early
						}
					}
					
					if (!gameResponse || !gameResponse.ok) return;
					
					let html;
					if (gameResponse.url && gameResponse.url.includes('allorigins')) {
						// Handle JSON response from allorigins
						const result = await gameResponse.json();
						html = result.contents;
					} else {
						// Handle direct response
						html = await gameResponse.text();
					}

					// Parse rating with count
					let rating = null;
					let ratingCount = null;
					let ratingLabel = null;
					// Try "4.23 stars from 3375" pattern
					let ratingMatch = html.match(/(\d+\.\d+)\s*stars?\s*from\s*(\d+)/i);
					if (ratingMatch) {
						rating = parseFloat(ratingMatch[1]).toFixed(2);
						ratingCount = ratingMatch[2];
					}
					// Try text rating like "Great (3375 ratings)"
					const labelMatch = html.match(/(Outstanding|Great|Good|Average|Bad|Terrible)\s*\((\d+)\s*ratings?\)/i);
					if (labelMatch) {
						ratingLabel = labelMatch[1];
						if (!ratingCount) ratingCount = labelMatch[2];
					}

					// Parse difficulty with count
					let difficulty = null;
					let difficultyCount = null;
					const diffMatch = html.match(/(Very Easy|Easy|Just Right|Tough|Very Hard|Unforgiving)\s*\((\d+)\)/i);
					if (diffMatch) {
						difficulty = diffMatch[1];
						difficultyCount = diffMatch[2];
					}

					// Parse length with count
					let length = null;
					let lengthCount = null;
					const lengthMatch = html.match(/(\d+(?:\.\d+)?)\s*Hours?\s*\((\d+)\)/i);
					if (lengthMatch) {
						length = lengthMatch[1] + 'h';
						lengthCount = lengthMatch[2];
					}

					// Update UI if we found any data
					if (rating || ratingLabel || difficulty || length) {
						infoDiv.style.display = 'block';

						// Rating
						if (rating || ratingLabel) {
							const displayRating = rating || ratingLabel;
							ratingEl.innerHTML = `<span class="icon solid fa-star"></span> ${displayRating}`;
							let tooltipHtml = '';
							if (rating) tooltipHtml += `<div class="gf-tooltip-row"><span>Score:</span><span>${rating} / 5</span></div>`;
							if (ratingLabel) tooltipHtml += `<div class="gf-tooltip-row"><span>Verdict:</span><span>${ratingLabel}</span></div>`;
							if (ratingCount) tooltipHtml += `<div class="gf-tooltip-row"><span>Votes:</span><span>${parseInt(ratingCount).toLocaleString()}</span></div>`;
							ratingTooltip.innerHTML = tooltipHtml;
						}

						// Difficulty
						if (difficulty) {
							difficultyEl.innerHTML = `<span class="icon solid fa-heartbeat"></span> ${difficulty}`;
							let tooltipHtml = `<div class="gf-tooltip-row"><span>Difficulty:</span><span>${difficulty}</span></div>`;
							if (difficultyCount) tooltipHtml += `<div class="gf-tooltip-row"><span>Votes:</span><span>${parseInt(difficultyCount).toLocaleString()}</span></div>`;
							difficultyTooltip.innerHTML = tooltipHtml;
						}

						// Length
						if (length) {
							lengthEl.innerHTML = `<span class="icon solid fa-clock"></span> ${length}`;
							let tooltipHtml = `<div class="gf-tooltip-row"><span>Main Story:</span><span>${length}</span></div>`;
							if (lengthCount) tooltipHtml += `<div class="gf-tooltip-row"><span>Votes:</span><span>${parseInt(lengthCount).toLocaleString()}</span></div>`;
							lengthTooltip.innerHTML = tooltipHtml;
						}
					}
				} catch (e) {
					// Silently fail - info is optional
				}
			}

			function selectPickerImage(img) {
				document.querySelectorAll('#pickerGrid img').forEach(i => i.classList.remove('selected'));
				img.classList.add('selected');
				selectedPickerUrl = img.dataset.url;
				document.getElementById('pickerSelectBtn').disabled = false;
			}

			async function confirmImageSelection() {
				if (!selectedPickerUrl) return;
				closeImagePicker();
				document.getElementById('imageUrl').value = selectedPickerUrl;
				// Auto-download the selected image
				await downloadAndResizeImage();
			}

			function openGoogleImages() {
				const q = document.getElementById('pickerSearchQuery').value || document.getElementById('modalGameName').textContent;
				window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(q + ' box art cover')}`, '_blank');
			}

			function confirmDeleteGame() {
				const gameName = document.getElementById('modalGameName').textContent;
				document.getElementById('deleteConfirmText').textContent = `Are you sure you want to delete "${gameName}"? This will remove the ROM file and its box art image.`;
				document.getElementById('deleteModal').classList.add('active');
			}

			async function executeDeleteGame() {
				try {
					const gameFileName = currentGame; // e.g. "Donkey Kong Country.sfc"
					const baseName = gameFileName.substring(0, gameFileName.lastIndexOf('.'));
					const consoleName = gameConsole || currentConsole;
					const consoleHandle = consoles[consoleName].handle;
					const imageHandle = consoles[consoleName].imgsHandle || consoleHandle;

					// Find the game object to get its directory handle (for subfolder support)
					const game = consoles[consoleName].games.find(g => g.name === gameFileName);
					const gameDir = game && game.dirHandle ? game.dirHandle : consoleHandle;

					// Delete the ROM file
					await gameDir.removeEntry(gameFileName);

					// Delete the image file if it exists (try both png and jpg)
					try {
						await imageHandle.removeEntry(baseName + '.png');
					} catch (e) {}
					try {
						await imageHandle.removeEntry(baseName + '.jpg');
					} catch (e) {}

					// Reset file inputs to prevent them from triggering
					document.getElementById('fileInput').value = '';
					document.getElementById('localImageInput').value = '';

					// Close all modals first
					closeModal('deleteModal');
					closeModal('gameModal');
					currentGame = null;

					// Remove focus from any element
					document.activeElement.blur();

					// Rescan and refresh view after short delay
					setTimeout(async () => {
						await scanExistingDirectory();
						// Check if console still exists after rescan
						if (consoles[consoleName]) {
							currentConsole = consoleName;
							await renderGames();
						} else {
							// Console folder is empty/deleted, go home
							showHome();
						}
					}, 100);

				} catch (e) {
					alert('Error deleting game: ' + e.message);
				}
			}

			// Context menu functions
			function showContextMenu(event, gameName, consoleName) {
				event.preventDefault();
				event.stopPropagation();
				contextMenuTarget = gameName;
				contextMenuConsole = consoleName || currentConsole;

				const menu = document.getElementById('contextMenu');
				menu.style.left = event.pageX + 'px';
				menu.style.top = event.pageY + 'px';
				menu.classList.add('active');
			}

			function hideContextMenu() {
				document.getElementById('contextMenu').classList.remove('active');
				contextMenuTarget = null;
				contextMenuConsole = null;
			}

			function contextMenuAction(action) {
				if (!contextMenuTarget) return;
				const gameName = contextMenuTarget;
				const consoleName = contextMenuConsole;
				hideContextMenu();

				switch (action) {
					case 'edit':
						openGameModal(gameName, consoleName);
						break;
					case 'search':
						openGameModal(gameName, consoleName);
						setTimeout(() => openImagePicker(), 100);
						break;
					case 'google':
						const baseName = gameName.substring(0, gameName.lastIndexOf('.'));
						window.open(`https://www.google.com/search?tbm=isch&q=${encodeURIComponent(baseName + ' box art cover')}`, '_blank');
						break;
					case 'rename':
						openRenameModal(gameName, consoleName);
						break;
					case 'delete':
						openGameModal(gameName, consoleName);
						setTimeout(() => confirmDeleteGame(), 100);
						break;
				}
			}

			let renameTarget = null;
			let renameConsole = null;

			function openRenameModal(gameName, consoleName) {
				renameTarget = gameName;
				renameConsole = consoleName || currentConsole;
				const baseName = gameName.substring(0, gameName.lastIndexOf('.'));
				document.getElementById('renameInput').value = baseName;
				document.getElementById('renameStatus').className = 'status-msg';
				document.getElementById('renameStatus').style.display = 'none';
				document.getElementById('renameModal').classList.add('active');
				// Focus and select the input
				setTimeout(() => {
					const input = document.getElementById('renameInput');
					input.focus();
					input.select();
				}, 100);
			}

			function openRenameFromGameModal() {
				if (currentGame && gameConsole) {
					openRenameModal(currentGame, gameConsole);
				}
			}

			function autoCleanName() {
				const input = document.getElementById('renameInput');
				const currentName = input.value;
				// Use cleanGameName logic but without extension handling since we don't have extension in input
				let cleaned = currentName;
				for (const pattern of cleanupPatterns) {
					cleaned = cleaned.replace(pattern, pattern.source === '\\s+' ? ' ' : '');
				}
				cleaned = cleaned.trim();
				if (cleaned !== currentName) {
					input.value = cleaned;
					input.focus();
					input.select();
				}
			}

			async function executeRename() {
				const targetConsole = renameConsole || currentConsole;
				if (!renameTarget || !targetConsole) return;

				const newName = document.getElementById('renameInput').value.trim();
				const status = document.getElementById('renameStatus');

				if (!newName) {
					status.className = 'status-msg error';
					status.textContent = 'Please enter a name';
					status.style.display = 'block';
					return;
				}

				// Validate filename characters
				const invalidChars = /[\/\\:*?"<>|]/;
				if (invalidChars.test(newName)) {
					status.className = 'status-msg error';
					status.textContent = 'Name contains invalid characters: / \\ : * ? " < > |';
					status.style.display = 'block';
					return;
				}

				const oldFileName = renameTarget;
				const oldBaseName = oldFileName.substring(0, oldFileName.lastIndexOf('.'));
				const ext = oldFileName.substring(oldFileName.lastIndexOf('.'));
				const newFileName = newName + ext;

				// Check if name changed
				if (oldBaseName === newName) {
					closeModal('renameModal');
					return;
				}

				status.textContent = 'Renaming...';
				status.style.display = 'block';
				status.className = 'status-msg';

				try {
					const consoleHandle = consoles[targetConsole].handle;
					const profile = deviceProfiles[currentDevice];
					let imageHandle;

					// Determine the correct image handle based on device type
					if (profile.catalogueStructure) {
						imageHandle = consoles[targetConsole].boxHandle || consoleHandle;
					} else if (profile.isMinUI) {
						imageHandle = consoles[targetConsole].resHandle || consoleHandle;
					} else if (profile.isNextUI) {
						imageHandle = consoles[targetConsole].mediaHandle || consoleHandle;
					} else {
						imageHandle = consoles[targetConsole].imgsHandle || consoleHandle;
					}

					// Find the game object to get its directory handle (for subfolder support)
					const game = consoles[targetConsole].games.find(g => g.name === oldFileName);
					const gameDir = game && game.dirHandle ? game.dirHandle : consoleHandle;

					// Read the old ROM file
					const oldRomHandle = await gameDir.getFileHandle(oldFileName);
					const oldRomFile = await oldRomHandle.getFile();
					const romData = await oldRomFile.arrayBuffer();

					// Create new ROM file with new name (in same directory)
					const newRomHandle = await gameDir.getFileHandle(newFileName, { create: true });
					const romWriter = await newRomHandle.createWritable();
					await romWriter.write(romData);
					await romWriter.close();

					// Delete old ROM file
					await gameDir.removeEntry(oldFileName);

					// Try to rename art file if it exists (check PNG first, then JPG)
					let artExt = null;
					let oldArtFileName, newArtFileName;

					// Determine old and new art filenames based on device type
					if (profile.isMinUI) {
						// MinUI: Art files include ROM extension (e.g., "Pokemon Red.gb.png")
						oldArtFileName = oldFileName;
						newArtFileName = newFileName;
					} else {
						// All other devices: Art files use basename only (e.g., "Pokemon Red.png")
						oldArtFileName = oldBaseName;
						newArtFileName = newName;
					}

					// Check if art file exists (PNG first, then JPG)
					try {
						await imageHandle.getFileHandle(oldArtFileName + '.png');
						artExt = '.png';
					} catch {
						try {
							await imageHandle.getFileHandle(oldArtFileName + '.jpg');
							artExt = '.jpg';
						} catch {}
					}

					if (artExt) {
						try {
							const oldArtHandle = await imageHandle.getFileHandle(oldArtFileName + artExt);
							const oldArtFile = await oldArtHandle.getFile();
							const artData = await oldArtFile.arrayBuffer();

							// Create new art file (keep same extension)
							const newArtHandle = await imageHandle.getFileHandle(newArtFileName + artExt, { create: true });
							const artWriter = await newArtHandle.createWritable();
							await artWriter.write(artData);
							await artWriter.close();

							// Delete old art file
							await imageHandle.removeEntry(oldArtFileName + artExt);
						} catch (e) {
							// Art file error, continue anyway
						}
					}

					status.className = 'status-msg success';
					status.textContent = 'Renamed successfully!';

					// Refresh after short delay
					setTimeout(async () => {
						closeModal('renameModal');

						// Update the game modal with new name
						if (currentGame === oldFileName) {
							currentGame = newFileName;
							const modalTitle = document.getElementById('modalGameName');
							modalTitle.textContent = newName;
							document.getElementById('gameTitleTooltip').textContent = newName;
							loadGameImage(newName);
						}

						renameTarget = null;
						renameConsole = null;
						await scanExistingDirectory();
						await renderGames();
						updateGameCountBadge();
					}, 500);

				} catch (e) {
					status.className = 'status-msg error';
					status.textContent = 'Error: ' + e.message;
				}
			}

			// Close context menu when clicking elsewhere
			document.addEventListener('click', (e) => {
				if (!e.target.closest('.context-menu')) {
					hideContextMenu();
				}
			});

			// Next Missing Art function
			function goToNextMissingArt() {
				const targetConsole = gameConsole || currentConsole;
				if (!targetConsole || !consoles[targetConsole]) return;

				const games = consoles[targetConsole].games;
				const currentIndex = games.findIndex(g => g.name === currentGame);

				// Find next game without art, starting after current game
				for (let i = 1; i <= games.length; i++) {
					const idx = (currentIndex + i) % games.length;
					if (!games[idx].hasImage) {
						closeModal('gameModal');
						setTimeout(() => openGameModal(games[idx].name, targetConsole), 100);
						return;
					}
				}

				// No more games without art
				alert('No more games without box art in this console!');
			}

			function updateNextGameButton() {
				const targetConsole = gameConsole || currentConsole;
				if (!targetConsole || !consoles[targetConsole]) return;
				const games = consoles[targetConsole].games;
				const hasMoreMissing = games.some(g => g.name !== currentGame && !g.hasImage);
				document.getElementById('nextGameBtn').disabled = !hasMoreMissing;
			}

			function selectSearchResult(img) {
				// Remove selected class from others
				document.querySelectorAll('#imageResults img').forEach(i => i.classList.remove('selected'));
				img.classList.add('selected');
				// Set the URL in the input field
				document.getElementById('imageUrl').value = img.dataset.url;
			}

			async function downloadAndResizeImage() {
				const url = document.getElementById('imageUrl').value.trim();
				const status = document.getElementById('imageStatus');
				if (!url) { status.className = 'status-msg error'; status.textContent = 'Enter a URL'; return; }
				status.textContent = 'Downloading...'; status.style.display = 'block'; status.className = 'status-msg';
				
				// Special handling for Libretro URLs
				if (url.includes('thumbnails.libretro.com')) {
					await downloadLibretroImage(url, status);
					return;
				}
				
				// Try multiple methods for general URLs
				try {
					// Method 1: Direct fetch first for better compatibility
					status.textContent = 'Trying direct download...';
					const controller = new AbortController();
					const timeout = setTimeout(() => controller.abort(), 30000);

					const r = await fetch(url, { 
						signal: controller.signal,
						referrerPolicy: 'no-referrer',
						headers: { 
							'Accept': 'image/*',
							'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
						},
						cache: 'no-cache'
					});
					clearTimeout(timeout);

					if (r.ok) {
						await processAndSaveImage(await r.blob());
						return;
					}
				} catch (e) {
					console.log('Direct download failed:', e.message);
				}
				
				// Method 2: Try CORS proxy
				try {
					status.textContent = 'Direct download failed, trying CORS proxy...';
					const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
					const r2 = await fetch(proxyUrl, { 
						headers: { 
							'Cache-Control': 'no-cache',
							'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
						}
					});
					if (r2.ok) {
						await processAndSaveImage(await r2.blob());
						return;
					} else {
						throw new Error(`Proxy failed with status ${r2.status}`);
					}
				} catch (e) {
					console.log('CORS proxy failed:', e.message);
				}
				
				// Method 3: Try alternative CORS proxy
				try {
					status.textContent = 'Trying alternative proxy...';
					const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
					const r3 = await fetch(proxyUrl, { 
						method: 'GET',
						cache: 'no-cache',
						headers: { 
							'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
						}
					});
					if (r3.ok) {
						const arrayBuffer = await r3.arrayBuffer();
						const blob = new Blob([arrayBuffer], {type: 'image/png'});
						await processAndSaveImage(blob);
						return;
					} else {
						throw new Error(`Alternative proxy failed with status ${r3.status}`);
					}
				} catch (e) {
					console.log('Alternative proxy failed:', e.message);
				}
				
				// If all methods failed
				status.className = 'status-msg error';
				status.textContent = 'Error downloading image. Try Local instead.';
			}

			async function downloadLibretroImage(url, status) {
				// Enhanced approach for Libretro URLs with better error handling and debugging
				console.log('Attempting to download Libretro image from:', url);
				status.textContent = 'Downloading Libretro image...';
				
				// Method 1: Try with a more compatible approach using XMLHttpRequest
				try {
					status.textContent = 'Trying XMLHttpRequest method...';
					const blob = await new Promise((resolve, reject) => {
						const xhr = new XMLHttpRequest();
						xhr.open('GET', url, true);
						xhr.responseType = 'blob';
						xhr.timeout = 30000; // 30 second timeout
						
						xhr.onload = function() {
							if (xhr.status === 200) {
								resolve(xhr.response);
							} else {
								reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
							}
						};
						
						xhr.onerror = function() {
							reject(new Error('Network error'));
						};
						
						xhr.ontimeout = function() {
							reject(new Error('Request timeout'));
						};
						
						xhr.send();
					});
					
					console.log('XMLHttpRequest successful, blob size:', blob.size);
					if (blob.size === 0) throw new Error('Empty image received');
					await processAndSaveImage(blob);
					return;
				} catch (e) {
					console.log('XMLHttpRequest method failed:', e.message);
					status.textContent = `XHR failed: ${e.message.substring(0, 30)}...`;
				}
				
				// Method 2: Try with referrer policy and custom headers
				try {
					status.textContent = 'Trying with custom headers...';
					const controller = new AbortController();
					const timeoutId = setTimeout(() => controller.abort(), 30000);
					
					const response = await fetch(url, { 
						signal: controller.signal,
						referrerPolicy: 'no-referrer',
						mode: 'no-cors', // Try no-cors mode
						cache: 'no-cache',
						headers: {
							'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',
							'Accept-Language': 'en-US,en;q=0.9',
							'Cache-Control': 'no-cache',
							'Pragma': 'no-cache',
							'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
						}
					});
					clearTimeout(timeoutId);
					
					console.log('Custom headers fetch response status:', response.status);
					// With no-cors mode, we can't check response.ok, but we can try to process the response
					const blob = await response.blob();
					console.log('Custom headers blob size:', blob.size);
					if (blob.size === 0) throw new Error('Empty image received');
					await processAndSaveImage(blob);
					return;
				} catch (e) {
					console.log('Custom headers fetch failed:', e.message);
					status.textContent = `Headers failed: ${e.message.substring(0, 30)}...`;
				}
				
				// Method 3: CORS proxy with different approach
				try {
					status.textContent = 'Using CORS proxy (method 1)...';
					const proxyUrl = `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`;
					console.log('Trying CORS proxy with URL:', proxyUrl);
					const response = await fetch(proxyUrl, {
						method: 'GET',
						cache: 'no-cache'
					});
					console.log('Proxy response status:', response.status);
					if (!response.ok) throw new Error(`Proxy error: HTTP ${response.status}`);
					const blob = await response.blob();
					console.log('Proxy blob size:', blob.size);
					if (blob.size === 0) throw new Error('Empty proxy image');
					await processAndSaveImage(blob);
					return;
				} catch (e) {
					console.log('CORS proxy (method 1) failed:', e.message);
					status.textContent = `Proxy 1 failed: ${e.message.substring(0, 30)}...`;
				}
				
				// Method 4: Alternative CORS proxy
				try {
					status.textContent = 'Using CORS proxy (method 2)...';
					const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
					console.log('Trying alternative proxy with URL:', proxyUrl);
					const response = await fetch(proxyUrl, { 
						method: 'GET',
						cache: 'no-cache',
						headers: { 
							'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
						}
					});
					console.log('Alternative proxy response status:', response.status);
					if (!response.ok) throw new Error(`Alt proxy error: HTTP ${response.status}`);
					const arrayBuffer = await response.arrayBuffer();
					console.log('Alternative proxy array buffer byte length:', arrayBuffer.byteLength);
					if (arrayBuffer.byteLength === 0) throw new Error('Empty image from alt proxy');
					const blob = new Blob([arrayBuffer], {type: 'image/png'});
					await processAndSaveImage(blob);
					return;
				} catch (e) {
					console.log('Alternative CORS proxy failed:', e.message);
					status.textContent = `Alt proxy failed: ${e.message.substring(0, 30)}...`;
				}
				
				// Method 5: Try with different CORS proxy
				try {
					status.textContent = 'Using CORS proxy (method 3)...';
					const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
					console.log('Trying different proxy with URL:', proxyUrl);
					const response = await fetch(proxyUrl, {
						method: 'GET',
						cache: 'no-cache',
						headers: {
							'Origin': 'https://nanoadcade.local',
							'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
						}
					});
					console.log('Different proxy response status:', response.status);
					if (!response.ok) throw new Error(`Diff proxy error: HTTP ${response.status}`);
					const blob = await response.blob();
					console.log('Different proxy blob size:', blob.size);
					if (blob.size === 0) throw new Error('Empty image from diff proxy');
					await processAndSaveImage(blob);
					return;
				} catch (e) {
					console.log('Different CORS proxy failed:', e.message);
					status.textContent = `Diff proxy failed: ${e.message.substring(0, 30)}...`;
				}
				
				// Method 6: Try with boxart URL as fallback (common alternative)
				try {
					status.textContent = 'Trying boxart URL...';
					// Convert Named_Boxarts URL to Boxarts URL
					const boxartUrl = url.replace('/Named_Boxarts/', '/Boxarts/');
					if (boxartUrl !== url) {
						console.log('Trying boxart URL:', boxartUrl);
						const controller = new AbortController();
						const timeoutId = setTimeout(() => controller.abort(), 30000);
						
						const response = await fetch(boxartUrl, { 
							signal: controller.signal,
							referrerPolicy: 'no-referrer',
							mode: 'cors',
							cache: 'no-cache',
							headers: {
								'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',
								'Accept-Language': 'en-US,en;q=0.9',
								'Cache-Control': 'no-cache',
								'Pragma': 'no-cache',
								'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
							}
						});
						clearTimeout(timeoutId);
						
						console.log('Boxart URL response status:', response.status);
						if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
						const blob = await response.blob();
						console.log('Boxart URL blob size:', blob.size);
						if (blob.size === 0) throw new Error('Empty image received from boxart URL');
						await processAndSaveImage(blob);
						return;
					}
				} catch (e) {
					console.log('Boxart URL failed:', e.message);
					status.textContent = `Boxart URL failed: ${e.message.substring(0, 30)}...`;
				}
				
				// Method 7: Try with Image element and canvas conversion (bypasses some CORS issues)
				try {
					status.textContent = 'Trying image element method...';
					const img = new Image();
					
					// Try loading with a timeout
					const loadImage = new Promise((resolve, reject) => {
						const timeoutId = setTimeout(() => {
							img.src = '';
							reject(new Error('Image load timeout'));
						}, 30000);
						
						img.onload = () => {
							clearTimeout(timeoutId);
							// Create canvas and convert to blob
							try {
								const canvas = document.createElement('canvas');
								canvas.width = img.naturalWidth;
								canvas.height = img.naturalHeight;
								const ctx = canvas.getContext('2d');
								ctx.drawImage(img, 0, 0);
								canvas.toBlob((blob) => {
									if (blob) {
										resolve(blob);
									} else {
										reject(new Error('Failed to create blob from canvas'));
									}
								}, 'image/png');
							} catch (canvasError) {
								reject(new Error(`Canvas error: ${canvasError.message}`));
							}
						};
						
						img.onerror = () => {
							clearTimeout(timeoutId);
							reject(new Error('Image failed to load'));
						};
						
						// Try loading the image
						img.src = url;
					});
					
					const blob = await loadImage;
					await processAndSaveImage(blob);
					return;
				} catch (e) {
					console.log('Image element method failed:', e.message);
					status.textContent = `Image method failed: ${e.message.substring(0, 30)}...`;
				}
				
				// Method 8: Try multiple proxy services in sequence
				try {
					status.textContent = 'Trying multiple proxy services...';
					const proxyServices = [
						`https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
						`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
						`https://corsproxy.io/?${encodeURIComponent(url)}`
					];
					
					for (let i = 0; i < proxyServices.length; i++) {
						try {
							status.textContent = `Trying proxy service ${i+1}/${proxyServices.length}...`;
							const proxyUrl = proxyServices[i];
							console.log(`Trying proxy service ${i+1}:`, proxyUrl);
							
							const response = await fetch(proxyUrl, {
								method: 'GET',
								cache: 'no-cache',
								headers: {
									'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
								}
							});
							
							if (response.ok) {
								const contentType = response.headers.get('content-type');
								console.log(`Proxy service ${i+1} response content-type:`, contentType);
								
								let blob;
								if (contentType && contentType.includes('application/json')) {
									// Handle JSON response from allorigins
									const data = await response.json();
									if (data.contents) {
										// Convert base64 data to blob
										const byteString = atob(data.contents.split(',')[1]);
										const mimeString = data.contents.split(',')[0].split(':')[1].split(';')[0];
										const ab = new ArrayBuffer(byteString.length);
										const ia = new Uint8Array(ab);
										for (let j = 0; j < byteString.length; j++) {
											ia[j] = byteString.charCodeAt(j);
										}
										blob = new Blob([ab], {type: mimeString});
									} else {
										throw new Error('Invalid JSON response from proxy');
									}
								} else {
									// Handle direct binary response
									blob = await response.blob();
								}
								
								if (blob && blob.size > 0) {
									console.log(`Proxy service ${i+1} successful, blob size:`, blob.size);
									await processAndSaveImage(blob);
									return;
								}
							}
						} catch (proxyError) {
							console.log(`Proxy service ${i+1} failed:`, proxyError.message);
							// Continue to next proxy service
						}
					}
				} catch (e) {
					console.log('Multiple proxy services failed:', e.message);
					status.textContent = `Proxies failed: ${e.message.substring(0, 30)}...`;
				}
				
				// Method 9: Try with a hidden iframe approach (bypasses some restrictions)
				try {
					status.textContent = 'Trying iframe approach...';
					
					// Create a temporary iframe to load the image
					const iframe = document.createElement('iframe');
					iframe.style.display = 'none';
					iframe.src = url;
					
					// Add to DOM temporarily
					document.body.appendChild(iframe);
					
					// Wait a bit for the iframe to load
					await new Promise(resolve => setTimeout(resolve, 3000));
					
					// Remove iframe
					document.body.removeChild(iframe);
					
					// Try direct fetch again after iframe load
					status.textContent = 'Retrying direct download after iframe...';
					const response = await fetch(url, {
						method: 'GET',
						cache: 'no-cache',
						referrerPolicy: 'no-referrer',
						headers: {
							'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',
							'Accept-Language': 'en-US,en;q=0.9',
							'Cache-Control': 'no-cache',
							'Pragma': 'no-cache',
							'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
						}
					});
					
					if (response.ok) {
						const blob = await response.blob();
						if (blob.size > 0) {
							await processAndSaveImage(blob);
							return;
						}
					}
				} catch (iframeError) {
					console.log('Iframe approach failed:', iframeError.message);
				}
				
				// Method 10: Last resort - try to fetch through a data URL approach
				try {
					status.textContent = 'Trying data URL approach...';
					
					// Create an image element and try to convert to data URL
					const img = new Image();
					img.crossOrigin = 'Anonymous';
					
					const dataUrlPromise = new Promise((resolve, reject) => {
						const timeoutId = setTimeout(() => {
							reject(new Error('Data URL conversion timeout'));
						}, 10000);
						
						img.onload = () => {
							clearTimeout(timeoutId);
							try {
								const canvas = document.createElement('canvas');
								canvas.width = img.naturalWidth;
								canvas.height = img.naturalHeight;
								const ctx = canvas.getContext('2d');
								ctx.drawImage(img, 0, 0);
								
								canvas.toBlob((blob) => {
									if (blob) {
										resolve(blob);
									} else {
										reject(new Error('Failed to create blob'));
									}
								}, 'image/png');
							} catch (canvasError) {
								reject(new Error(`Canvas error: ${canvasError.message}`));
							}
						};
						
						img.onerror = () => {
							clearTimeout(timeoutId);
							reject(new Error('Image failed to load for data URL conversion'));
						};
						
						img.src = url;
					});
					
					const blob = await dataUrlPromise;
					await processAndSaveImage(blob);
					return;
				} catch (dataUrlError) {
					console.log('Data URL approach failed:', dataUrlError.message);
				}
				
				// If we reach here, all methods failed
				console.error('All download methods failed for Libretro image');
				status.className = 'status-msg error';
				status.innerHTML = 'Error downloading Libretro image. <a href="'+url+'" target="_blank" style="color:#60a5fa;text-decoration:underline;">Try opening in new tab</a>, then save and upload manually.';
			}

			function selectLocalImage() { document.getElementById('localImageInput').click(); }
			async function handleLocalImage(e) { if (e.target.files[0]) await processAndSaveImage(e.target.files[0]); }
			
			// Calculate CRC32 for a specific game file (used when needed)
			async function calculateGameCRC(gameName, consoleName, forceRecalculate = false) {
				try {
					const consoleData = consoles[consoleName];
					if (!consoleData) return null;
					
					// Find game object
					const game = consoleData.games.find(g => g.name === gameName);
					if (!game) return null;
					
					// Check if CRC already calculated (unless forced)
					if (game.crc32 && !forceRecalculate) return game.crc32;
					
					// Get file handle and calculate CRC
					// Try direct handle first (for games in console root)
					let fileHandle;
					try {
						fileHandle = await consoleData.handle.getFileHandle(gameName);
					} catch (e) {
						// If direct access fails, try using game's directory handle (for games in subdirectories)
						if (game.dirHandle) {
							fileHandle = await game.dirHandle.getFileHandle(gameName);
						} else {
							throw e; // Re-throw if no directory handle available
						}
					}
					
					const file = await fileHandle.getFile();
					const buffer = await file.arrayBuffer();
					const crc32 = calculateCRC32(buffer);
					
					// Store CRC in game object
					game.crc32 = crc32;
					return crc32;
				} catch (e) {
					console.log('Error calculating CRC:', e);
					return null;
				}
			}
			
			// CRC32 calculation function for file integrity checking
			function calculateCRC32(buffer) {
				const crcTable = new Uint32Array(256);
				
				// Generate CRC table
				for (let i = 0; i < 256; i++) {
					let c = i;
					for (let j = 0; j < 8; j++) {
						c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
					}
					crcTable[i] = c;
				}
				
				// Calculate CRC32
				let crc = 0 ^ (-1);
				const view = new Uint8Array(buffer);
				for (let i = 0; i < view.length; i++) {
					crc = (crc >>> 8) ^ crcTable[(crc ^ view[i]) & 0xFF];
				}
				
				// Convert to unsigned 32-bit integer
				return (crc ^ (-1)) >>> 0;
			}
			
			// Function to download Libretro artwork based on CRC32
			async function downloadLibretroByCRC() {
				const status = document.getElementById('imageStatus');
				status.textContent = 'Getting game CRC32...';
				status.style.display = 'block';
				status.className = 'status-msg';
				
				try {
					// First get the current game's CRC32
					const crc32 = await calculateGameCRC(currentGame, gameConsole, false);
					if (!crc32) {
						status.className = 'status-msg error';
						status.textContent = 'Could not calculate CRC32. Game file may be missing.';
						return;
					}
					
					const crcHex = crc32.toString(16).toUpperCase();
					status.textContent = `CRC32: ${crcHex} - Looking up in database...`;
					
					// Fetch the rdb_entries.json file with retry logic
					let rdbData = null;
					let retries = 3;
					while (retries > 0) {
						try {
							const response = await fetch('rdb_entries.json');
							if (response.ok) {
								rdbData = await response.json();
								break;
							} else {
								throw new Error(`HTTP ${response.status}: ${response.statusText}`);
							}
						} catch (e) {
							retries--;
							if (retries === 0) throw e;
							await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second before retry
						}
					}
					
					if (!rdbData) {
						status.className = 'status-msg error';
						status.textContent = 'Failed to load rdb_entries.json after multiple attempts';
						return;
					}
					
					const gameInfo = rdbData[crcHex];
					
					if (!gameInfo) {
						status.className = 'status-msg error';
						status.textContent = `No entry found for CRC32: ${crcHex}`;
						return;
					}
					
					status.textContent = `Found: ${gameInfo.name}`;
					
					// Construct the Libretro URL based on system and name
					// Format: https://thumbnails.libretro.com/{system}/Named_Boxarts/{name}.png
					const system = encodeURIComponent(gameInfo.system);
					const name = encodeURIComponent(gameInfo.name);
					const imageUrl = `https://thumbnails.libretro.com/${system}/Named_Boxarts/${name}.png`;
					
					// Also try the boxart URL as a fallback
					const boxartUrl = `https://thumbnails.libretro.com/${system}/Boxarts/${name}.png`;
					
					// Try the main URL first
					document.getElementById('imageUrl').value = imageUrl;
					
					// Trigger the download
					try {
						await downloadAndResizeImage();
					} catch (error) {
						console.log('Primary Libretro URL failed, trying boxart URL');
						// If the primary URL fails, try the boxart URL
						document.getElementById('imageUrl').value = boxartUrl;
						try {
							await downloadAndResizeImage();
						} catch (secondError) {
							// If both URLs fail, try constructing URL without encoding
							console.log('Both encoded URLs failed, trying unencoded versions');
							const unencodedImageUrl = `https://thumbnails.libretro.com/${gameInfo.system}/Named_Boxarts/${gameInfo.name}.png`;
							const unencodedBoxartUrl = `https://thumbnails.libretro.com/${gameInfo.system}/Boxarts/${gameInfo.name}.png`;
							
							document.getElementById('imageUrl').value = unencodedImageUrl;
							try {
								await downloadAndResizeImage();
							} catch (thirdError) {
								document.getElementById('imageUrl').value = unencodedBoxartUrl;
								await downloadAndResizeImage();
							}
						}
					}
					
				} catch (error) {
					console.error('Error downloading from Libretro by CRC32:', error);
					status.className = 'status-msg error';
					status.textContent = `Error: ${error.message}`;
				}
			}

			async function processAndSaveImage(inputData) {
				const status = document.getElementById('imageStatus');
				const targetConsole = gameConsole || currentConsole;
				let blob = null;
				
				try {
					// Handle different input types
					if (inputData instanceof Blob) {
						blob = inputData;
					} else if (typeof inputData === 'string') {
						// If it's a string, assume it's a data URL
						try {
							const response = await fetch(inputData);
							blob = await response.blob();
						} catch (e) {
							throw new Error('Failed to convert data URL to blob');
						}
					} else {
						throw new Error('Invalid input type');
					}
					
					// Make sure blob is valid
					if (!blob || blob.size === 0) {
						throw new Error('Invalid image blob');
					}
					
					let img;
					try {
						// Try to create image bitmap from blob
						img = await createImageBitmap(blob);
					} catch (e) {
						console.log('createImageBitmap failed, using fallback:', e);
						
						// Create object URL for the blob
						const objectURL = URL.createObjectURL(blob);
						
						try {
							// Try loading as an Image element
							img = await new Promise((resolve, reject) => {
								const imgEl = new Image();
								imgEl.onload = () => {
									// Clean up the object URL
									URL.revokeObjectURL(objectURL);
									
									// Create a canvas to get the image as a bitmap
									const canvas = document.createElement('canvas');
									canvas.width = imgEl.naturalWidth || imgEl.width;
									canvas.height = imgEl.naturalHeight || imgEl.height;
									const ctx = canvas.getContext('2d');
									ctx.drawImage(imgEl, 0, 0);
									
									// Try to get the image bitmap from the canvas
									try {
										resolve(createImageBitmap(canvas));
									} catch (bitmapError) {
										// Final fallback: just use the Image element directly
										console.log('Canvas bitmap creation failed, using Image element directly');
										resolve(imgEl);
									}
								};
								
								imgEl.onerror = () => {
									URL.revokeObjectURL(objectURL);
									reject(new Error('Image loading failed'));
								};
								
								imgEl.src = objectURL;
							});
						} catch (e) {
							// Clean up the object URL if something went wrong
							URL.revokeObjectURL(objectURL);
							throw e;
						}
					}
					
					const profile = deviceProfiles[currentDevice];
					const maxSize = profile.imageSize || 240;
					
					// Handle both ImageBitmap and HTMLImageElement
					const imgWidth = img.width || (img.naturalWidth || img.width);
					const imgHeight = img.height || (img.naturalHeight || img.height);

					// Calculate scale factor to fit within maxSize while preserving aspect ratio
					const scale = Math.min(maxSize / imgWidth, maxSize / imgHeight);
					const newWidth = Math.round(imgWidth * scale);
					const newHeight = Math.round(imgHeight * scale);

					const canvas = document.createElement('canvas');
					canvas.width = newWidth;
					canvas.height = newHeight;

					// Use high quality image scaling
					const ctx = canvas.getContext('2d');
					ctx.imageSmoothingEnabled = true;
					ctx.imageSmoothingQuality = 'high';
					ctx.drawImage(img, 0, 0, newWidth, newHeight);

					const resized = await new Promise(r => canvas.toBlob(r, 'image/png'));

					const baseName = currentGame.substring(0, currentGame.lastIndexOf('.'));
					let imageDir;
					let imageFileName;

					if (profile.catalogueStructure) {
						// Trimui Brick / MustardOS: Box art goes in MUOS/info/catalogue/<system>/box/
						if (consoles[targetConsole].boxHandle) {
							imageDir = consoles[targetConsole].boxHandle;
						} else {
							// Need to create box folder in catalogue structure
							try {
								const muosDir = await directoryHandle.getDirectoryHandle('MUOS', { create: true });
								const infoDir = await muosDir.getDirectoryHandle('info', { create: true });
								const catalogueDir = await infoDir.getDirectoryHandle('catalogue', { create: true });
								const catalogueName = consoles[targetConsole].catalogueName || targetConsole;
								const systemDir = await catalogueDir.getDirectoryHandle(catalogueName, { create: true });
								const boxDir = await systemDir.getDirectoryHandle('box', { create: true });
								consoles[targetConsole].boxHandle = boxDir;
								imageDir = boxDir;
							} catch (e) {
								// Fallback: create box in ROM folder
								const boxDir = await consoles[targetConsole].handle.getDirectoryHandle('box', { create: true });
								consoles[targetConsole].boxHandle = boxDir;
								imageDir = boxDir;
							}
						}
						imageFileName = baseName + '.png';
					} else if (profile.isMinUI) {
						// MinUI: Save to .res folder with ROM extension (e.g., "Pokemon Red.gb.png")
						if (consoles[targetConsole].resHandle) {
							imageDir = consoles[targetConsole].resHandle;
						} else {
							imageDir = await consoles[targetConsole].handle.getDirectoryHandle('.res', { create: true });
							consoles[targetConsole].resHandle = imageDir;
						}
						imageFileName = currentGame + '.png';
					} else if (profile.isNextUI) {
						// NextUI: Save to .media folder without ROM extension (e.g., "Pokemon Red.png")
						if (consoles[targetConsole].mediaHandle) {
							imageDir = consoles[targetConsole].mediaHandle;
						} else {
							imageDir = await consoles[targetConsole].handle.getDirectoryHandle('.media', { create: true });
							consoles[targetConsole].mediaHandle = imageDir;
						}
						imageFileName = baseName + '.png';
					} else if (profile.emoji === 'ðŸ§…') {
						// Onion OS: Create/get Imgs folder
						imageDir = consoles[targetConsole].imgsHandle || consoles[targetConsole].handle;
						if (!consoles[targetConsole].imgsHandle) {
							imageDir = await consoles[targetConsole].handle.getDirectoryHandle('Imgs', { create: true });
							consoles[targetConsole].imgsHandle = imageDir;
						}
						imageFileName = baseName + '.png';
					} else {
						// RG Nano / Generic: Save directly to console folder
						imageDir = consoles[targetConsole].handle;
						imageFileName = baseName + '.png';
					}

					const fh = await imageDir.getFileHandle(imageFileName, { create: true });
					const w = await fh.createWritable();
					await w.write(resized);
					await w.close();

					document.getElementById('modalImagePreview').innerHTML = `<img src="${await createObjectURL(resized)}">`;
					// Update game metadata
					const game = consoles[targetConsole].games.find(g => g.name === currentGame);
					if (game) {
						game.hasImage = true;
						game.imageExt = '.png';
					}

					status.className = 'status-msg success';
					status.textContent = `Saved! (${newWidth}x${newHeight})`;
					renderConsoleList(); renderGames(); updateStats(); updateGameCountBadge();
					updateNextGameButton();
				} catch (e) { status.className = 'status-msg error'; status.textContent = 'Error: ' + e.message; }
			}

			function closeModal(id) { document.getElementById(id).classList.remove('active'); }

			function toggleMobileMenu() {
				const overlay = document.getElementById('mobileMenuOverlay');
				overlay.classList.toggle('active');
				document.body.classList.toggle('mobile-menu-open');
			}

			function renderMobileConsoleList() {
				const mobileList = document.getElementById('mobileConsoleList');
				if (!mobileList) return;

				const desktopList = document.getElementById('consoleList');
				if (!desktopList) return;

				// Clone the desktop list items for mobile
				mobileList.innerHTML = desktopList.innerHTML;

				// Add click handlers to close menu
				const mobileLinks = mobileList.querySelectorAll('a');
				mobileLinks.forEach(link => {
					link.addEventListener('click', () => {
						toggleMobileMenu();
					});
				});
			}

			// Update mobile menu whenever desktop menu updates
			const originalRenderConsoleList = renderConsoleList;
			renderConsoleList = function() {
				originalRenderConsoleList.apply(this, arguments);
				renderMobileConsoleList();
			};

			function openUploadModal() {
				if (!directoryHandle) { alert('Scan a drive first'); return; }
				filesToUpload = [];
				document.getElementById('fileList').innerHTML = '';
				document.getElementById('uploadStatus').className = 'status-msg';
				// Pre-select current console if one is selected
				if (currentConsole) {
					document.getElementById('uploadConsoleSelect').value = currentConsole;
				}
				document.getElementById('uploadModal').classList.add('active');
			}

			document.addEventListener('DOMContentLoaded', () => {
				const dz = document.getElementById('dropZone');
				dz.addEventListener('dragover', e => { e.preventDefault(); dz.classList.add('dragover'); });
				dz.addEventListener('dragleave', () => dz.classList.remove('dragover'));
				dz.addEventListener('drop', e => { e.preventDefault(); dz.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });
				document.querySelectorAll('.modal-overlay').forEach(m => m.addEventListener('mousedown', e => { if (e.target === m) m.classList.remove('active'); }));
				// Initialize mobile menu with Home link
				renderMobileConsoleList();
			});

			function handleFileSelect(e) { handleFiles(e.target.files); }
			function handleFiles(files) {
				const list = document.getElementById('fileList');
				for (const file of files) {
					const clean = cleanGameName(file.name);
					filesToUpload.push({ file, originalName: file.name, cleanName: clean });
					list.innerHTML += `<div class="file-item"><span class="original">${file.name}</span><span class="clean">â†’ ${clean}</span></div>`;
				}
			}

			async function uploadFiles() {
				const consoleName = document.getElementById('uploadConsoleSelect').value;
				const status = document.getElementById('uploadStatus');
				if (!consoleName) { status.className = 'status-msg error'; status.textContent = 'Select a console'; return; }
				if (!filesToUpload.length) { status.className = 'status-msg error'; status.textContent = 'No files'; return; }

				status.textContent = 'Uploading...'; status.style.display = 'block';
				try {
					let ch;
					try { ch = await directoryHandle.getDirectoryHandle(consoleName); }
					catch { ch = await directoryHandle.getDirectoryHandle(consoleName, { create: true }); }

					for (const item of filesToUpload) {
						const fh = await ch.getFileHandle(item.cleanName, { create: true });
						const w = await fh.createWritable();
						await w.write(item.file);
						await w.close();
					}

					status.className = 'status-msg success';
					status.textContent = `Uploaded ${filesToUpload.length} file(s)!`;
					const uploadedToConsole = consoleName;
					const uploadedGames = filesToUpload.map(f => f.cleanName); // Keep full filename with extension
					filesToUpload = [];
					document.getElementById('fileList').innerHTML = '';

					// Reset file input to prevent it from triggering again
					document.getElementById('fileInput').value = '';

					// Close modal and refresh after brief delay to show success message
					setTimeout(async () => {
						closeModal('uploadModal');
						document.activeElement.blur();
						await scanExistingDirectory();
						// Refresh the view for the console we uploaded to
						if (consoles[uploadedToConsole]) {
							currentConsole = uploadedToConsole;
							document.getElementById('currentConsoleName').textContent = uploadedToConsole;
							document.getElementById('intro').style.display = 'none';
							document.getElementById('games').style.display = 'block';
							await renderGames();
							// Open game modal for the first uploaded game to add artwork
							if (uploadedGames.length > 0) {
								setTimeout(() => openGameModal(uploadedGames[0], uploadedToConsole), 300);
							}
						}
					}, 1000);
				} catch (e) { status.className = 'status-msg error'; status.textContent = 'Error: ' + e.message; }
			}

			// Register Service Worker for PWA
			if ('serviceWorker' in navigator) {
				window.addEventListener('load', () => {
					navigator.serviceWorker.register('sw.js')
						.then(reg => console.log('NanoArcade: Service Worker registered', reg.scope))
						.catch(err => console.log('NanoArcade: Service Worker registration failed', err));
				});
			}

			// ============================================
			// Save Manager
			// ============================================

			// RG Nano emulator to console mapping (lowercase, .sav files)
			const rgNanoEmulatorMap = {
				'gambatte': ['Game Boy', 'Game Boy Color', 'GB', 'GBC'],
				'gpsp': ['Game Boy Advance', 'GBA'],
				'fceumm': ['NES', 'Nintendo Entertainment System', 'FC', 'Famicom'],
				'snes9x2005': ['SNES', 'Super Nintendo', 'SFC', 'Super Famicom'],
				'picodrive': ['Sega Genesis', 'Genesis', 'Mega Drive', 'MD', 'Game Gear', 'GG'],
				'pcsx_rearmed': ['PS1', 'PlayStation', 'PSX', 'PS']
			};

			// Onion OS emulator to console mapping (mixed case, .srm files)
			// Used by Miyoo Mini, Miyoo Mini+, Miyoo Flip
			const onionEmulatorMap = {
				'Gambatte': ['Game Boy', 'Game Boy Color', 'GB', 'GBC'],
				'gpSP': ['Game Boy Advance', 'GBA'],
				'FCEUmm': ['NES', 'Nintendo Entertainment System', 'FC', 'Famicom'],
				'Supafaust': ['SNES', 'Super Nintendo', 'SFC', 'Super Famicom'],
				'Snes9x 2005 Plus': ['SNES', 'Super Nintendo', 'SFC', 'Super Famicom'],
				'PicoDrive': ['Sega Genesis', 'Genesis', 'Mega Drive', 'MD', 'Game Gear', 'GG', 'Sega Master System', 'Master System', 'MS'],
				'Genesis Plus GX': ['Sega Genesis', 'Genesis', 'Mega Drive', 'MD', 'Game Gear', 'GG', 'Sega Master System', 'Master System', 'MS'],
				'PCSX-ReARMed': ['PS1', 'PlayStation', 'PSX', 'PS'],
				'Beetle PCE Fast': ['PC Engine', 'TurboGrafx-16', 'PCE', 'PCECD'],
				'Mednafen PCE Fast': ['PC Engine', 'TurboGrafx-16', 'PCE', 'PCECD'],
				'FinalBurn Neo': ['Arcade', 'Neo Geo', 'NEOGEO', 'CPS1', 'CPS2', 'CPS3'],
				'FB Alpha 2012': ['Arcade', 'Neo Geo', 'NEOGEO'],
				'FB Alpha 2012 CPS-3': ['CPS3'],
				'MAME 2003-Plus': ['Arcade', 'MAME'],
				'Beetle NeoPop': ['Neo Geo Pocket', 'Neo Geo Pocket Color', 'NGP', 'NGPC'],
				'Beetle WonderSwan': ['WonderSwan', 'WonderSwan Color', 'WS', 'WSC'],
				'Stella 2014': ['Atari 2600', 'Atari', '2600'],
				'Handy': ['Atari Lynx', 'Lynx']
			};

			// MinUI/NextUI system to console mapping (.sav files)
			// Uses system folder names from MinUI
			const minuiEmulatorMap = {
				'GB': ['Game Boy', 'Game Boy Color', 'GB', 'GBC', 'Game Boy (GB)', 'Game Boy Color (GBC)'],
				'GBA': ['Game Boy Advance', 'GBA', 'Game Boy Advance (GBA)'],
				'FC': ['NES', 'Nintendo Entertainment System', 'FC', 'Famicom', 'Nintendo Entertainment System (FC)', 'NES (NES)', 'Nintendo (NES)'],
				'FDS': ['Famicom Disk System', 'FDS', 'Famicom Disk System (FDS)'],
				'SFC': ['SNES', 'Super Nintendo', 'SFC', 'Super Famicom', 'Super Nintendo (SFC)', 'SNES (SFC)'],
				'N64': ['Nintendo 64', 'N64', 'Nintendo 64 (N64)'],
				'MD': ['Sega Genesis', 'Genesis', 'Mega Drive', 'MD', 'Sega Genesis (MD)', 'Genesis (MD)'],
				'SMS': ['Sega Master System', 'Master System', 'MS', 'SMS', 'Sega Master System (SMS)', 'Master System (SMS)'],
				'GG': ['Game Gear', 'GG', 'Game Gear (GG)'],
				'PS': ['PS1', 'PlayStation', 'PSX', 'PS', 'PlayStation (PS)', 'PS1 (PS)', 'Sony PlayStation (PS)'],
				'PCE': ['PC Engine', 'TurboGrafx-16', 'PCE', 'PCECD', 'PC Engine (PCE)', 'TurboGrafx-16 (PCE)', 'NEC PC Engine (PCE)'],
				'NEOGEO': ['Neo Geo', 'NEOGEO', 'Neo Geo (NEOGEO)'],
				'NGP': ['Neo Geo Pocket', 'Neo Geo Pocket Color', 'NGP', 'NGPC', 'Neo Geo Pocket (NGP)', 'Neo Geo Pocket Color (NGP)', 'SNK Neo Geo Pocket (NGP)'],
				'VB': ['Virtual Boy', 'VB', 'Virtual Boy (VB)'],
				'POKE': ['Pokemon Mini', 'POKE', 'Pokemon Mini (POKE)'],
				'PICO': ['Pico-8', 'PICO-8', 'PICO', 'Pico-8 (PICO)'],
				'WS': ['WonderSwan', 'WonderSwan Color', 'WS', 'WSC', 'Bandai WonderSwan (WS)']
			};

			function isOnionOS(deviceType) {
				return deviceType === 'onion' || deviceType === 'miyooflip';
			}

			function isMinUIBased(deviceType) {
				const profile = deviceProfiles[deviceType];
				return profile && (profile.isMinUI || profile.isNextUI);
			}

			function getSaveExtension(deviceType) {
				if (isOnionOS(deviceType)) return '.srm';
				if (isMinUIBased(deviceType)) return '.sav';
				return '.sav';
			}

			function getEmulatorForConsole(consoleName, deviceType) {
				let emulatorMap;
				if (isOnionOS(deviceType)) {
					emulatorMap = onionEmulatorMap;
				} else if (isMinUIBased(deviceType)) {
					emulatorMap = minuiEmulatorMap;
				} else {
					emulatorMap = rgNanoEmulatorMap;
				}

				for (const [emulator, consoleNames] of Object.entries(emulatorMap)) {
					if (consoleNames.some(c => c.toLowerCase() === consoleName.toLowerCase())) {
						return emulator;
					}
				}
				return null;
			}

			function openSaveManager() {
				const gameName = currentGame;
				const baseName = gameName.substring(0, gameName.lastIndexOf('.'));
				document.getElementById('saveGameName').textContent = baseName;
				document.getElementById('saveModal').classList.add('active');
				loadLocalSaves(baseName);
			}

			// Get the save folder handle based on device type
			async function getSaveFolderHandle(deviceType, emulator, create = false) {
				if (isOnionOS(deviceType)) {
					// Onion OS: Saves/CurrentProfile/saves/[emulator]/
					const savesHandle = await directoryHandle.getDirectoryHandle('Saves', { create }).catch(() => null);
					if (!savesHandle) return null;
					const profileHandle = await savesHandle.getDirectoryHandle('CurrentProfile', { create }).catch(() => null);
					if (!profileHandle) return null;
					const savesFolderHandle = await profileHandle.getDirectoryHandle('saves', { create }).catch(() => null);
					if (!savesFolderHandle) return null;
					return await savesFolderHandle.getDirectoryHandle(emulator, { create }).catch(() => null);
				} else if (isMinUIBased(deviceType)) {
					// MinUI/NextUI: .userdata/[system]/Saves/
					const userdataHandle = await directoryHandle.getDirectoryHandle('.userdata', { create }).catch(() => null);
					if (!userdataHandle) return null;
					const systemHandle = await userdataHandle.getDirectoryHandle(emulator, { create }).catch(() => null);
					if (!systemHandle) return null;
					return await systemHandle.getDirectoryHandle('Saves', { create }).catch(() => null);
				} else {
					// RG Nano: FunKey/.picoarch/data/[emulator]/
					const funKeyHandle = await directoryHandle.getDirectoryHandle('FunKey', { create }).catch(() => null);
					if (!funKeyHandle) return null;
					const picoarchHandle = await funKeyHandle.getDirectoryHandle('.picoarch', { create }).catch(() => null);
					if (!picoarchHandle) return null;
					const dataHandle = await picoarchHandle.getDirectoryHandle('data', { create }).catch(() => null);
					if (!dataHandle) return null;
					return await dataHandle.getDirectoryHandle(emulator, { create }).catch(() => null);
				}
			}

			function getSaveLocationText(deviceType, emulator) {
				if (isOnionOS(deviceType)) {
					return `Saves/CurrentProfile/saves/${emulator}/`;
				} else if (isMinUIBased(deviceType)) {
					return `.userdata/${emulator}/Saves/`;
				} else {
					return `FunKey/.picoarch/data/${emulator}/`;
				}
			}

			async function loadLocalSaves(baseName) {
				const list = document.getElementById('localSavesList');
				list.innerHTML = '<div class="loading-container" style="padding: 2em;"><div class="spinner"></div><div class="loading-text">Checking for saves...</div></div>';

				// Check if device supports save management
				const supportsSaves = currentDevice === 'rgnano' || isOnionOS(currentDevice) || isMinUIBased(currentDevice);
				if (!directoryHandle || !supportsSaves) {
					list.innerHTML = '<p style="text-align: center; color: rgba(255,255,255,0.6); padding: 2em;">Save management is not available for this device.</p>';
					return;
				}

				const emulator = getEmulatorForConsole(gameConsole || currentConsole, currentDevice);
				if (!emulator) {
					list.innerHTML = '<p style="text-align: center; color: rgba(255,255,255,0.6); padding: 2em;">Console not supported for save management.</p>';
					return;
				}

				const saveExt = getSaveExtension(currentDevice);

				try {
					const emulatorHandle = await getSaveFolderHandle(currentDevice, emulator, false);
					if (!emulatorHandle) {
						list.innerHTML = '<p style="text-align: center; color: rgba(255,255,255,0.6); padding: 2em;">No saves found.</p>';
						return;
					}

					// Look for save files matching the game name
					const saves = [];
					for await (const entry of emulatorHandle.values()) {
						if (entry.kind === 'file' && entry.name.endsWith(saveExt)) {
							const saveBaseName = entry.name.substring(0, entry.name.lastIndexOf('.'));
							// Check if this save matches the current game (fuzzy match)
							if (saveBaseName.toLowerCase() === baseName.toLowerCase() ||
								saveBaseName.toLowerCase().includes(baseName.toLowerCase()) ||
								baseName.toLowerCase().includes(saveBaseName.toLowerCase())) {
								const file = await entry.getFile();
								saves.push({
									name: entry.name,
									handle: entry,
									size: file.size,
									modified: file.lastModified
								});
							}
						}
					}

					if (saves.length === 0) {
						const saveLocation = getSaveLocationText(currentDevice, emulator);
						list.innerHTML = `
							<div style="text-align: center; padding: 2em; color: rgba(255,255,255,0.6);">
								<span class="icon solid fa-folder-open" style="font-size: 2em; margin-bottom: 0.5em; display: block;"></span>
								<p>No save files found for this game.</p>
								<p style="font-size: 0.85em;">Save location: ${saveLocation}</p>
							</div>
						`;
						return;
					}

					// Display saves
					let html = '';
					for (const save of saves) {
						const date = new Date(save.modified).toLocaleDateString();
						const size = (save.size / 1024).toFixed(1) + ' KB';
						html += `
							<div style="display: flex; align-items: center; padding: 0.75em; background: rgba(34, 211, 238, 0.1); border-radius: 8px; margin-bottom: 0.5em;">
								<span class="icon solid fa-save" style="color: #22d3ee; margin-right: 0.75em; font-size: 1.2em;"></span>
								<div style="flex: 1;">
									<div style="font-weight: 500;">${save.name}</div>
									<div style="font-size: 0.8em; color: rgba(255,255,255,0.5);">${size} â€¢ ${date}</div>
								</div>
								<button class="btn-3d small" onclick="downloadSave('${save.name}')" title="Download">
									<span class="icon solid fa-download"></span>
								</button>
								<button class="btn-3d small red" onclick="event.stopPropagation(); deleteSave('${save.name}')" title="Delete" style="margin-left: 0.25em;">
									<span class="icon solid fa-trash"></span>
								</button>
							</div>
						`;
					}
					list.innerHTML = html;

				} catch (e) {
					console.error('Error loading saves:', e);
					list.innerHTML = '<p style="text-align: center; color: rgba(255,255,255,0.6); padding: 2em;">Error loading saves: ' + e.message + '</p>';
				}
			}

			async function downloadSave(saveName) {
				const emulator = getEmulatorForConsole(gameConsole || currentConsole, currentDevice);
				try {
					const emulatorHandle = await getSaveFolderHandle(currentDevice, emulator, false);
					if (!emulatorHandle) {
						alert('Save folder not found.');
						return;
					}
					const fileHandle = await emulatorHandle.getFileHandle(saveName);
					const file = await fileHandle.getFile();

					// Create download
					const url = URL.createObjectURL(file);
					const a = document.createElement('a');
					a.href = url;
					a.download = saveName;
					a.click();
					URL.revokeObjectURL(url);
				} catch (e) {
					alert('Error downloading save: ' + e.message);
				}
			}

			let pendingDeleteSave = null;

			function deleteSave(saveName) {
				pendingDeleteSave = saveName;
				document.getElementById('deleteSaveConfirmText').innerHTML = `Are you sure you want to delete <strong>"${saveName}"</strong>?<br><span style="font-size: 0.85em; color: rgba(255,255,255,0.6);">This cannot be undone.</span>`;
				document.getElementById('deleteSaveModal').classList.add('active');
			}

			async function executeDeleteSave() {
				if (!pendingDeleteSave) return;

				const saveName = pendingDeleteSave;
				const emulator = getEmulatorForConsole(gameConsole || currentConsole, currentDevice);
				try {
					const emulatorHandle = await getSaveFolderHandle(currentDevice, emulator, false);
					if (!emulatorHandle) {
						alert('Save folder not found.');
						return;
					}
					await emulatorHandle.removeEntry(saveName);

					closeModal('deleteSaveModal');
					pendingDeleteSave = null;

					// Reload saves list
					const baseName = currentGame.substring(0, currentGame.lastIndexOf('.'));
					loadLocalSaves(baseName);
				} catch (e) {
					alert('Error deleting save: ' + e.message);
				}
			}

			function uploadLocalSave() {
				document.getElementById('saveFileInput').click();
			}

			async function handleSaveUpload(event) {
				const file = event.target.files[0];
				if (!file) return;

				const emulator = getEmulatorForConsole(gameConsole || currentConsole, currentDevice);
				if (!emulator) {
					alert('Console not supported for save management.');
					return;
				}

				try {
					// Navigate to save folder, creating if needed
					const emulatorHandle = await getSaveFolderHandle(currentDevice, emulator, true);
					if (!emulatorHandle) {
						alert('Could not create save folder.');
						return;
					}

					// Write save file
					const fileHandle = await emulatorHandle.getFileHandle(file.name, { create: true });
					const writable = await fileHandle.createWritable();
					await writable.write(file);
					await writable.close();

					// Reload saves list
					const baseName = currentGame.substring(0, currentGame.lastIndexOf('.'));
					loadLocalSaves(baseName);

					// Clear file input
					event.target.value = '';
				} catch (e) {
					alert('Error uploading save: ' + e.message);
				}
			}

			// Batch Libretro processing
			let batchProcessing = false;
			let batchCancelled = false;
			let batchSuccessCount = 0;
			let batchFailCount = 0;
			let batchTotalCount = 0;
			let batchCurrentIndex = 0;
			let batchGames = [];
			let batchConcurrency = 15; // Process 15 games at a time

			let rdbData = null;
			async function batchFetchLibretroImages() {
				if (!currentConsole || !consoles[currentConsole]) {
					alert('No console selected');
					return;
				}

				// Get games without images
				const consoleGames = consoles[currentConsole].games;
				const gamesWithoutArt = consoleGames.filter(game => !game.hasImage);
				
				if (gamesWithoutArt.length === 0) {
					alert('All games in this console already have artwork!');
					return;
				}

				// Reset batch variables
				batchProcessing = true;
				batchCancelled = false;
				batchSuccessCount = 0;
				batchFailCount = 0;
				batchTotalCount = gamesWithoutArt.length;
				batchCurrentIndex = 0;
				batchGames = [...gamesWithoutArt];

				// Load rdb_entries.json once
				try {
					const response = await fetch('rdb_entries.json');
					if (response.ok) {
						rdbData = await response.json();
					} else {
						throw new Error('Failed to load rdb_entries.json');
					}
				} catch (e) {
					alert('Could not load rdb_entries.json file. Please try again later.');
					batchProcessing = false;
					return;
				}

				// Show batch modal
				document.getElementById('batchLibretroModal').classList.add('active');
				updateBatchProgress();

				// Start batch processing
				await processBatchQueue();

				// Check if processing was completed (not cancelled)
				if (!batchCancelled) {
					// Show final status
					setTimeout(() => {
						alert(`Batch processing complete!\n\nSuccessfully downloaded: ${batchSuccessCount}\nFailed: ${batchFailCount}`);
						// Change Cancel button to Close button
						document.getElementById('batchCancelBtn').style.display = 'none';
						document.getElementById('batchCloseBtn').style.display = 'inline-flex';
						// Update status text
						document.getElementById('batchCurrentGame').textContent = 'Batch processing complete!';
					}, 500);
				} else {
					// If cancelled was already handled, make sure Close button is visible
					document.getElementById('batchCancelBtn').style.display = 'none';
					document.getElementById('batchCloseBtn').style.display = 'inline-flex';
				}

				// Cleanup
				batchProcessing = false;
			}

			// Process games in batches with true concurrency
			async function processBatchQueue() {
				const activePromises = new Set();
				let queueIndex = 0;

				// å¹¶å‘å¤„ç†æ¸¸æˆï¼Œä¿æŒæœ€å¤š2ä¸ªå¹¶å‘
				while (queueIndex < batchGames.length && !batchCancelled) {
					// å¡«å……å¹¶å‘æ§½ä½ï¼Œæœ€å¤šåŒæ—¶å¤„ç†batchConcurrencyä¸ªæ¸¸æˆ
					while (activePromises.size < batchConcurrency && queueIndex < batchGames.length && !batchCancelled) {
						const gameIndex = queueIndex++;
						const promise = processBatchGame(gameIndex)
							.then(result => {
								activePromises.delete(promise);
								batchCurrentIndex++;
								updateBatchProgress();
								return result;
							})
							.catch(error => {
								activePromises.delete(promise);
								batchCurrentIndex++;
								updateBatchProgress();
								console.error('Error processing game:', error);
								return { success: false, error };
							});
						
						activePromises.add(promise);
					}

					// ç­‰å¾…è‡³å°‘ä¸€ä¸ªä»»åŠ¡å®Œæˆ
					if (activePromises.size > 0) {
						await Promise.race(activePromises);
					}
				}

				// ç­‰å¾…æ‰€æœ‰å‰©ä½™ä»»åŠ¡å®Œæˆ
				if (activePromises.size > 0) {
					await Promise.allSettled(activePromises);
				}
			}

			// Process a single game in the batch
			async function processBatchGame(index) {
				try {
					const game = batchGames[index];
					const gameName = game.name;
					const baseName = gameName.substring(0, gameName.lastIndexOf('.'));
					
					// Find the game card for this game
					const gameCard = document.querySelector(`#gamesGrid .game-card[data-game-name="${gameName}"]`);
					if (gameCard) {
						// Add loading overlay to the game card
						const imgContainer = gameCard.querySelector('.image-container');
						if (imgContainer && !imgContainer.querySelector('.batch-loading-overlay')) {
							const loadingOverlay = document.createElement('div');
							loadingOverlay.className = 'batch-loading-overlay';
							loadingOverlay.innerHTML = `
								<div class="batch-spinner"></div>
								<div class="batch-loading-text">å¤„ç†ä¸­...</div>
							`;
							imgContainer.appendChild(loadingOverlay);
						}
					}
					
					// Update current game display
					document.getElementById('batchCurrentGame').textContent = `Processing: ${baseName}`;
					
					// Add to log
					addToBatchLog(`<div style="color: rgba(255,255,255,0.7); margin-bottom: 0.25em;">Processing: ${baseName}</div>`);
					
					// Calculate CRC32
					const crc32 = await calculateGameCRC(gameName, currentConsole, false);
					if (!crc32) {
						throw new Error('Could not calculate CRC32');
					}
					
					const crcHex = crc32.toString(16).toUpperCase();
					addToBatchLog(`<div style="color: rgba(255,255,255,0.5); margin-bottom: 0.25em; margin-left: 1em;">CRC32: ${crcHex}</div>`);
					
					// Lookup in database
					const gameInfo = rdbData[crcHex];
					if (!gameInfo) {
						throw new Error(`No entry found for CRC32: ${crcHex}`);
					}
					
					addToBatchLog(`<div style="color: rgba(255,255,255,0.5); margin-bottom: 0.25em; margin-left: 1em;">Found: ${gameInfo.name}</div>`);
					
					// Construct Libretro URL
					const system = encodeURIComponent(gameInfo.system);
					const name = encodeURIComponent(gameInfo.name);
					const imageUrl = `https://thumbnails.libretro.com/${system}/Named_Boxarts/${name}.png`;
					const boxartUrl = `https://thumbnails.libretro.com/${system}/Boxarts/${name}.png`;
					
					// Try to download image
					let imageDownloaded = false;
					
					// Try main URL first
					try {
						addToBatchLog(`<div style="color: rgba(96,165,250,0.7); margin-bottom: 0.25em; margin-left: 1em;">Trying main URL...</div>`);
						await downloadImageForBatch(imageUrl, gameName, baseName);
						imageDownloaded = true;
					} catch (e) {
						addToBatchLog(`<div style="color: rgba(245,158,11,0.7); margin-bottom: 0.25em; margin-left: 1em;">Main URL failed: ${e.message.substring(0, 50)}...</div>`);
						
						// Try boxart URL as fallback
						try {
							addToBatchLog(`<div style="color: rgba(96,165,250,0.7); margin-bottom: 0.25em; margin-left: 1em;">Trying boxart URL...</div>`);
							await downloadImageForBatch(boxartUrl, gameName, baseName);
							imageDownloaded = true;
						} catch (e2) {
							addToBatchLog(`<div style="color: rgba(245,158,11,0.7); margin-bottom: 0.25em; margin-left: 1em;">Boxart URL failed: ${e2.message.substring(0, 50)}...</div>`);
							
							// Try unencoded URLs
							try {
								addToBatchLog(`<div style="color: rgba(96,165,250,0.7); margin-bottom: 0.25em; margin-left: 1em;">Trying unencoded URL...</div>`);
								const unencodedImageUrl = `https://thumbnails.libretro.com/${gameInfo.system}/Named_Boxarts/${gameInfo.name}.png`;
								await downloadImageForBatch(unencodedImageUrl, gameName, baseName);
								imageDownloaded = true;
							} catch (e3) {
								addToBatchLog(`<div style="color: rgba(245,158,11,0.7); margin-bottom: 0.25em; margin-left: 1em;">Unencoded URL failed</div>`);
							}
						}
					}
					
					if (imageDownloaded) {
						batchSuccessCount++;
						addToBatchLog(`<div style="color: #4ade80; margin-bottom: 0.25em; margin-left: 1em;">âœ“ Success!</div>`);
						
						// Update game object
						game.hasImage = true;
						game.imageExt = '.png';
						
						// Remove loading overlay
						if (gameCard) {
							const imgContainer = gameCard.querySelector('.image-container');
							const loadingOverlay = imgContainer?.querySelector('.batch-loading-overlay');
							if (loadingOverlay) {
								loadingOverlay.remove();
							}
						}
						
						// Refresh the game image in the UI
						if (gameCard) {
							setTimeout(() => {
								refreshGameCard(gameCard, gameName, game);
							}, 500);
						}
						
						return { success: true, game };
					} else {
						throw new Error('All URL attempts failed');
					}
				} catch (e) {
					batchFailCount++;
					addToBatchLog(`<div style="color: #f87171; margin-bottom: 0.25em; margin-left: 1em;">âœ— Failed: ${e.message}</div>`);
					
					// Remove loading overlay on error
					if (gameCard) {
						const imgContainer = gameCard.querySelector('.image-container');
						const loadingOverlay = imgContainer?.querySelector('.batch-loading-overlay');
						if (loadingOverlay) {
							loadingOverlay.remove();
						}
					}
					
					return { success: false, error: e.message };
				}
			}

			// Refresh a game card after image download
			function refreshGameCard(gameCard, gameName, game) {
				const imgContainer = gameCard.querySelector('.image-container');
				
				// Get the correct image path based on device profile
				const profile = deviceProfiles[currentDevice];
				let imagePath;
				
				if (profile.catalogueStructure) {
					// Trimui Brick / MustardOS
					const baseName = gameName.substring(0, gameName.lastIndexOf('.'));
					imagePath = `images/${currentConsole}/${baseName}.png?${Date.now()}`;
				} else if (profile.isMinUI) {
					// MinUI
					imagePath = `images/${currentConsole}/${gameName}.png?${Date.now()}`;
				} else if (profile.isNextUI) {
					// NextUI
					const baseName = gameName.substring(0, gameName.lastIndexOf('.'));
					imagePath = `images/${currentConsole}/${baseName}.png?${Date.now()}`;
				} else if (profile.emoji === 'ðŸ§…') {
					// Onion OS
					const baseName = gameName.substring(0, gameName.lastIndexOf('.'));
					imagePath = `images/${currentConsole}/${baseName}.png?${Date.now()}`;
				} else {
					// Generic
					const baseName = gameName.substring(0, gameName.lastIndexOf('.'));
					imagePath = `images/${currentConsole}/${baseName}.png?${Date.now()}`;
				}
				
				// Create new image element
				const img = document.createElement('img');
				img.onload = function() {
					imgContainer.innerHTML = '';
					imgContainer.appendChild(img);
				};
				img.onerror = function() {
					// If image fails to load, show missing image
					imgContainer.innerHTML = `<div class="no-image"><span class="icon solid fa-image"></span></div>`;
				};
				img.src = imagePath;
			}

			// Download and save image for batch processing
			async function downloadImageForBatch(url, gameName, baseName) {
				// Try multiple download methods, similar to the main downloadLibretroImage function
				let blob = null;
				
				// Method 1: Direct fetch
				try {
					console.log('Batch download: Trying direct fetch method');
					const response = await fetch(url, {
						referrerPolicy: 'no-referrer',
						headers: { 
							'Accept': 'image/*',
							'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
						},
						cache: 'no-cache'
					});
					
					if (response.ok) {
						blob = await response.blob();
						if (blob.size === 0) {
							throw new Error('Empty image received');
						}
						console.log('Batch download: Direct fetch succeeded');
					}
				} catch (e) {
					console.log('Batch download: Direct fetch failed, trying CORS proxy methods');
				}
				
				// Method 2: CORS proxy with codetabs
				if (!blob || blob.size === 0) {
					try {
						console.log('Batch download: Trying CORS proxy (method 1)');
						const proxyUrl = `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`;
						const response = await fetch(proxyUrl, {
							method: 'GET',
							cache: 'no-cache'
						});
						if (response.ok) {
							blob = await response.blob();
							if (blob.size === 0) {
								throw new Error('Empty proxy image');
							}
							console.log('Batch download: CORS proxy (method 1) succeeded');
						}
					} catch (e) {
						console.log('Batch download: CORS proxy (method 1) failed');
					}
				}
				
				// Method 3: Alternative CORS proxy
				if (!blob || blob.size === 0) {
					try {
						console.log('Batch download: Trying CORS proxy (method 2)');
						const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
						const response = await fetch(proxyUrl, { 
							method: 'GET',
							cache: 'no-cache',
							headers: { 
								'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
							}
						});
						if (response.ok) {
							const arrayBuffer = await response.arrayBuffer();
							if (arrayBuffer.byteLength > 0) {
								blob = new Blob([arrayBuffer], {type: 'image/png'});
								console.log('Batch download: CORS proxy (method 2) succeeded');
							}
						}
					} catch (e) {
						console.log('Batch download: Alternative CORS proxy failed');
					}
				}
				
				// Method 4: corsproxy.io proxy
				if (!blob || blob.size === 0) {
					try {
						console.log('Batch download: Trying CORS proxy (method 3)');
						const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
						const response = await fetch(proxyUrl);
						if (response.ok) {
							blob = await response.blob();
							console.log('Batch download: CORS proxy (method 3) succeeded');
						}
					} catch (e) {
						console.log('Batch download: corsproxy.io failed');
					}
				}
				
				if (!blob || blob.size === 0) {
					throw new Error('All download methods failed');
				}
				
				// Create image bitmap to verify
				const img = await createImageBitmap(blob);
				
				// Get device profile and resize image
				const profile = deviceProfiles[currentDevice];
				const maxSize = profile.imageSize || 240;
				
				const imgWidth = img.width;
				const imgHeight = img.height;
				
				// Calculate scale factor
				const scale = Math.min(maxSize / imgWidth, maxSize / imgHeight);
				const newWidth = Math.round(imgWidth * scale);
				const newHeight = Math.round(imgHeight * scale);
				
				const canvas = document.createElement('canvas');
				canvas.width = newWidth;
				canvas.height = newHeight;
				
				const ctx = canvas.getContext('2d');
				ctx.imageSmoothingEnabled = true;
				ctx.imageSmoothingQuality = 'high';
				ctx.drawImage(img, 0, 0, newWidth, newHeight);
				
				const resized = await new Promise(r => canvas.toBlob(r, 'image/png'));
				
				// Determine where to save the image based on device profile
				let imageDir;
				let imageFileName;
				
				if (profile.catalogueStructure) {
					// Trimui Brick / MustardOS
					if (consoles[currentConsole].boxHandle) {
						imageDir = consoles[currentConsole].boxHandle;
					} else {
						try {
							const muosDir = await directoryHandle.getDirectoryHandle('MUOS', { create: true });
							const infoDir = await muosDir.getDirectoryHandle('info', { create: true });
							const catalogueDir = await infoDir.getDirectoryHandle('catalogue', { create: true });
							const catalogueName = consoles[currentConsole].catalogueName || currentConsole;
							const systemDir = await catalogueDir.getDirectoryHandle(catalogueName, { create: true });
							const boxDir = await systemDir.getDirectoryHandle('box', { create: true });
							consoles[currentConsole].boxHandle = boxDir;
							imageDir = boxDir;
						} catch (e) {
							const boxDir = await consoles[currentConsole].handle.getDirectoryHandle('box', { create: true });
							consoles[currentConsole].boxHandle = boxDir;
							imageDir = boxDir;
						}
					}
					imageFileName = baseName + '.png';
				} else if (profile.isMinUI) {
					// MinUI
					if (consoles[currentConsole].resHandle) {
						imageDir = consoles[currentConsole].resHandle;
					} else {
						imageDir = await consoles[currentConsole].handle.getDirectoryHandle('.res', { create: true });
						consoles[currentConsole].resHandle = imageDir;
					}
					imageFileName = gameName + '.png'; // Include ROM extension
				} else if (profile.isNextUI) {
					// NextUI
					if (consoles[currentConsole].mediaHandle) {
						imageDir = consoles[currentConsole].mediaHandle;
					} else {
						imageDir = await consoles[currentConsole].handle.getDirectoryHandle('.media', { create: true });
						consoles[currentConsole].mediaHandle = imageDir;
					}
					imageFileName = baseName + '.png';
				} else if (profile.emoji === 'ðŸ§…') {
					// Onion OS
					imageDir = consoles[currentConsole].imgsHandle || consoles[currentConsole].handle;
					if (!consoles[currentConsole].imgsHandle) {
						imageDir = await consoles[currentConsole].handle.getDirectoryHandle('Imgs', { create: true });
						consoles[currentConsole].imgsHandle = imageDir;
					}
					imageFileName = baseName + '.png';
				} else {
					// Generic
					imageDir = consoles[currentConsole].handle;
					imageFileName = baseName + '.png';
				}
				
				// Save the image
				const fh = await imageDir.getFileHandle(imageFileName, { create: true });
				const w = await fh.createWritable();
				await w.write(resized);
				await w.close();
			}

			// Update batch progress display
			function updateBatchProgress() {
				const progress = ((batchSuccessCount + batchFailCount) / batchTotalCount) * 100;
				document.getElementById('batchProgressBar').style.width = `${progress}%`;
				document.getElementById('batchProgressText').textContent = `${batchSuccessCount + batchFailCount}/${batchTotalCount}`;
				document.getElementById('batchSuccessCount').textContent = batchSuccessCount;
				document.getElementById('batchFailCount').textContent = batchFailCount;
			}

			// Add message to batch log
			function addToBatchLog(message) {
				const logElement = document.getElementById('batchLog');
				logElement.innerHTML += message;
				logElement.scrollTop = logElement.scrollHeight;
			}

			// Cancel batch processing
			function cancelBatchProcessing() {
				if (!batchProcessing) {
					// If not processing, just close the modal
					closeBatchModal();
					return;
				}
				
				if (confirm('Are you sure you want to cancel batch processing?')) {
					batchCancelled = true;
					batchProcessing = false;
					// Update status
					document.getElementById('batchCurrentGame').textContent = 'Batch processing cancelled!';
					// Change Cancel button to Close button
					document.getElementById('batchCancelBtn').style.display = 'none';
					document.getElementById('batchCloseBtn').style.display = 'inline-flex';
					
					// Refresh games list to show any that were processed
					renderGames();
					updateStats();
					updateGameCountBadge();
				}
			}

			// Close batch modal and refresh UI
			function closeBatchModal() {
				closeModal('batchLibretroModal');
				// Refresh games list to show any that were processed
				renderGames();
				updateStats();
				updateGameCountBadge();
			}

			// PWA Install functionality
			let deferredPrompt;

			window.addEventListener('beforeinstallprompt', (e) => {
				// Prevent Chrome from showing the default prompt
				e.preventDefault();
				// Save the event for later
				deferredPrompt = e;
				// Show our install button
				document.getElementById('installPwaBtn').style.display = 'inline-flex';
				console.log('NanoArcade: Install prompt ready');
			});

			window.addEventListener('appinstalled', () => {
				// Hide the install button after installation
				document.getElementById('installPwaBtn').style.display = 'none';
				deferredPrompt = null;
				console.log('NanoArcade: App installed successfully');
			});

			async function installPwa() {
				if (!deferredPrompt) {
					// Already installed or not supported
					alert('App is already installed or installation is not available in this browser.');
					return;
				}
				// Show the install prompt
				deferredPrompt.prompt();
				// Wait for user response
				const { outcome } = await deferredPrompt.userChoice;
				console.log('NanoArcade: Install prompt outcome:', outcome);
				// Clear the prompt
				deferredPrompt = null;
				// Hide button regardless of outcome
				document.getElementById('installPwaBtn').style.display = 'none';
			}
		</script>

	</body>
</html>
